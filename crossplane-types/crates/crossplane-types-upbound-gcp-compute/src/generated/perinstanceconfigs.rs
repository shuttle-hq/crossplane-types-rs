// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// PerInstanceConfigSpec defines the desired state of PerInstanceConfig
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta2", kind = "PerInstanceConfig", plural = "perinstanceconfigs")]
#[kube(status = "PerInstanceConfigStatus")]
pub struct PerInstanceConfigSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<PerInstanceConfigDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: PerInstanceConfigForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<PerInstanceConfigInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<PerInstanceConfigProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<PerInstanceConfigPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<PerInstanceConfigWriteConnectionSecretToRef>,
}

/// PerInstanceConfigSpec defines the desired state of PerInstanceConfig
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProvider {
    /// The instance group manager this instance config is part of.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGroupManager")]
    #[builder(default)]
    pub instance_group_manager: Option<String>,
    /// Reference to a InstanceGroupManager in compute to populate instanceGroupManager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGroupManagerRef")]
    #[builder(default)]
    pub instance_group_manager_ref: Option<PerInstanceConfigForProviderInstanceGroupManagerRef>,
    /// Selector for a InstanceGroupManager in compute to populate instanceGroupManager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGroupManagerSelector")]
    #[builder(default)]
    pub instance_group_manager_selector: Option<PerInstanceConfigForProviderInstanceGroupManagerSelector>,
    /// The minimal action to perform on the instance during an update.
    /// Default is NONE. Possible values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimalAction")]
    #[builder(default)]
    pub minimal_action: Option<String>,
    /// The most disruptive action to perform on the instance during an update.
    /// Default is REPLACE. Possible values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mostDisruptiveAllowedAction")]
    #[builder(default)]
    pub most_disruptive_allowed_action: Option<String>,
    /// The name for this per-instance config and its corresponding instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The preserved state for this instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preservedState")]
    #[builder(default)]
    pub preserved_state: Option<PerInstanceConfigForProviderPreservedState>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// When true, deleting this config will immediately remove the underlying instance.
    /// When false, deleting this config will use the behavior as determined by remove_instance_on_destroy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeInstanceOnDestroy")]
    #[builder(default)]
    pub remove_instance_on_destroy: Option<bool>,
    /// When true, deleting this config will immediately remove any specified state from the underlying instance.
    /// When false, deleting this config will not immediately remove any state from the underlying instance.
    /// State will be removed on the next instance recreation or update.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeInstanceStateOnDestroy")]
    #[builder(default)]
    pub remove_instance_state_on_destroy: Option<bool>,
    /// Zone where the containing instance group manager is located
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub zone: Option<String>,
    /// Reference to a InstanceGroupManager in compute to populate zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneRef")]
    #[builder(default)]
    pub zone_ref: Option<PerInstanceConfigForProviderZoneRef>,
    /// Selector for a InstanceGroupManager in compute to populate zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneSelector")]
    #[builder(default)]
    pub zone_selector: Option<PerInstanceConfigForProviderZoneSelector>,
}

/// Reference to a InstanceGroupManager in compute to populate instanceGroupManager.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderInstanceGroupManagerRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigForProviderInstanceGroupManagerRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderInstanceGroupManagerRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigForProviderInstanceGroupManagerRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigForProviderInstanceGroupManagerRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigForProviderInstanceGroupManagerRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigForProviderInstanceGroupManagerRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceGroupManager in compute to populate instanceGroupManager.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderInstanceGroupManagerSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigForProviderInstanceGroupManagerSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderInstanceGroupManagerSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigForProviderInstanceGroupManagerSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigForProviderInstanceGroupManagerSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigForProviderInstanceGroupManagerSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigForProviderInstanceGroupManagerSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The preserved state for this instance.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderPreservedState {
    /// Stateful disks for the instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disk: Option<Vec<PerInstanceConfigForProviderPreservedStateDisk>>,
    /// Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIp")]
    #[builder(default)]
    pub external_ip: Option<Vec<PerInstanceConfigForProviderPreservedStateExternalIp>>,
    /// Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIp")]
    #[builder(default)]
    pub internal_ip: Option<Vec<PerInstanceConfigForProviderPreservedStateInternalIp>>,
    /// Preserved metadata defined for this instance. This is a list of key->value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderPreservedStateDisk {
    /// A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
    /// The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION.
    /// NEVER - detach the disk when the VM is deleted, but do not delete the disk.
    /// ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently
    /// deleted from the instance group.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    #[builder(default)]
    pub delete_rule: Option<String>,
    /// A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// The mode of the disk.
    /// Default value is READ_WRITE.
    /// Possible values are: READ_ONLY, READ_WRITE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
    /// The URI of an existing persistent disk to attach under the specified device-name in the format
    /// projects/project-id/zones/zone/disks/disk-name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<String>,
    /// Reference to a Disk in compute to populate source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRef")]
    #[builder(default)]
    pub source_ref: Option<PerInstanceConfigForProviderPreservedStateDiskSourceRef>,
    /// Selector for a Disk in compute to populate source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSelector")]
    #[builder(default)]
    pub source_selector: Option<PerInstanceConfigForProviderPreservedStateDiskSourceSelector>,
}

/// Reference to a Disk in compute to populate source.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderPreservedStateDiskSourceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigForProviderPreservedStateDiskSourceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderPreservedStateDiskSourceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigForProviderPreservedStateDiskSourceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigForProviderPreservedStateDiskSourceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigForProviderPreservedStateDiskSourceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigForProviderPreservedStateDiskSourceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Disk in compute to populate source.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderPreservedStateDiskSourceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigForProviderPreservedStateDiskSourceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderPreservedStateDiskSourceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigForProviderPreservedStateDiskSourceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigForProviderPreservedStateDiskSourceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigForProviderPreservedStateDiskSourceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigForProviderPreservedStateDiskSourceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderPreservedStateExternalIp {
    /// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    #[builder(default)]
    pub auto_delete: Option<String>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    #[builder(default)]
    pub interface_name: Option<String>,
    /// Ip address representation
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default)]
    pub ip_address: Option<PerInstanceConfigForProviderPreservedStateExternalIpIpAddress>,
}

/// Ip address representation
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderPreservedStateExternalIpIpAddress {
    /// The URL of the reservation for this IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub address: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderPreservedStateInternalIp {
    /// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    #[builder(default)]
    pub auto_delete: Option<String>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    #[builder(default)]
    pub interface_name: Option<String>,
    /// Ip address representation
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default)]
    pub ip_address: Option<PerInstanceConfigForProviderPreservedStateInternalIpIpAddress>,
}

/// Ip address representation
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderPreservedStateInternalIpIpAddress {
    /// The URL of the reservation for this IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub address: Option<String>,
}

/// Reference to a InstanceGroupManager in compute to populate zone.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderZoneRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigForProviderZoneRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderZoneRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigForProviderZoneRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigForProviderZoneRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigForProviderZoneRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigForProviderZoneRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceGroupManager in compute to populate zone.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderZoneSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigForProviderZoneSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigForProviderZoneSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigForProviderZoneSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigForProviderZoneSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigForProviderZoneSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigForProviderZoneSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProvider {
    /// The instance group manager this instance config is part of.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGroupManager")]
    #[builder(default)]
    pub instance_group_manager: Option<String>,
    /// Reference to a InstanceGroupManager in compute to populate instanceGroupManager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGroupManagerRef")]
    #[builder(default)]
    pub instance_group_manager_ref: Option<PerInstanceConfigInitProviderInstanceGroupManagerRef>,
    /// Selector for a InstanceGroupManager in compute to populate instanceGroupManager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGroupManagerSelector")]
    #[builder(default)]
    pub instance_group_manager_selector: Option<PerInstanceConfigInitProviderInstanceGroupManagerSelector>,
    /// The minimal action to perform on the instance during an update.
    /// Default is NONE. Possible values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimalAction")]
    #[builder(default)]
    pub minimal_action: Option<String>,
    /// The most disruptive action to perform on the instance during an update.
    /// Default is REPLACE. Possible values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mostDisruptiveAllowedAction")]
    #[builder(default)]
    pub most_disruptive_allowed_action: Option<String>,
    /// The name for this per-instance config and its corresponding instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The preserved state for this instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preservedState")]
    #[builder(default)]
    pub preserved_state: Option<PerInstanceConfigInitProviderPreservedState>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// When true, deleting this config will immediately remove the underlying instance.
    /// When false, deleting this config will use the behavior as determined by remove_instance_on_destroy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeInstanceOnDestroy")]
    #[builder(default)]
    pub remove_instance_on_destroy: Option<bool>,
    /// When true, deleting this config will immediately remove any specified state from the underlying instance.
    /// When false, deleting this config will not immediately remove any state from the underlying instance.
    /// State will be removed on the next instance recreation or update.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeInstanceStateOnDestroy")]
    #[builder(default)]
    pub remove_instance_state_on_destroy: Option<bool>,
    /// Zone where the containing instance group manager is located
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub zone: Option<String>,
    /// Reference to a InstanceGroupManager in compute to populate zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneRef")]
    #[builder(default)]
    pub zone_ref: Option<PerInstanceConfigInitProviderZoneRef>,
    /// Selector for a InstanceGroupManager in compute to populate zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneSelector")]
    #[builder(default)]
    pub zone_selector: Option<PerInstanceConfigInitProviderZoneSelector>,
}

/// Reference to a InstanceGroupManager in compute to populate instanceGroupManager.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderInstanceGroupManagerRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigInitProviderInstanceGroupManagerRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderInstanceGroupManagerRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigInitProviderInstanceGroupManagerRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigInitProviderInstanceGroupManagerRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigInitProviderInstanceGroupManagerRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigInitProviderInstanceGroupManagerRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceGroupManager in compute to populate instanceGroupManager.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderInstanceGroupManagerSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigInitProviderInstanceGroupManagerSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderInstanceGroupManagerSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigInitProviderInstanceGroupManagerSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigInitProviderInstanceGroupManagerSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigInitProviderInstanceGroupManagerSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigInitProviderInstanceGroupManagerSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The preserved state for this instance.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderPreservedState {
    /// Stateful disks for the instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disk: Option<Vec<PerInstanceConfigInitProviderPreservedStateDisk>>,
    /// Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIp")]
    #[builder(default)]
    pub external_ip: Option<Vec<PerInstanceConfigInitProviderPreservedStateExternalIp>>,
    /// Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIp")]
    #[builder(default)]
    pub internal_ip: Option<Vec<PerInstanceConfigInitProviderPreservedStateInternalIp>>,
    /// Preserved metadata defined for this instance. This is a list of key->value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderPreservedStateDisk {
    /// A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
    /// The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION.
    /// NEVER - detach the disk when the VM is deleted, but do not delete the disk.
    /// ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently
    /// deleted from the instance group.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    #[builder(default)]
    pub delete_rule: Option<String>,
    /// A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// The mode of the disk.
    /// Default value is READ_WRITE.
    /// Possible values are: READ_ONLY, READ_WRITE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
    /// The URI of an existing persistent disk to attach under the specified device-name in the format
    /// projects/project-id/zones/zone/disks/disk-name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<String>,
    /// Reference to a Disk in compute to populate source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRef")]
    #[builder(default)]
    pub source_ref: Option<PerInstanceConfigInitProviderPreservedStateDiskSourceRef>,
    /// Selector for a Disk in compute to populate source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSelector")]
    #[builder(default)]
    pub source_selector: Option<PerInstanceConfigInitProviderPreservedStateDiskSourceSelector>,
}

/// Reference to a Disk in compute to populate source.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderPreservedStateDiskSourceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigInitProviderPreservedStateDiskSourceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderPreservedStateDiskSourceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigInitProviderPreservedStateDiskSourceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigInitProviderPreservedStateDiskSourceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigInitProviderPreservedStateDiskSourceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigInitProviderPreservedStateDiskSourceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Disk in compute to populate source.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderPreservedStateDiskSourceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigInitProviderPreservedStateDiskSourceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderPreservedStateDiskSourceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigInitProviderPreservedStateDiskSourceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigInitProviderPreservedStateDiskSourceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigInitProviderPreservedStateDiskSourceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigInitProviderPreservedStateDiskSourceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderPreservedStateExternalIp {
    /// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    #[builder(default)]
    pub auto_delete: Option<String>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    #[builder(default)]
    pub interface_name: Option<String>,
    /// Ip address representation
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default)]
    pub ip_address: Option<PerInstanceConfigInitProviderPreservedStateExternalIpIpAddress>,
}

/// Ip address representation
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderPreservedStateExternalIpIpAddress {
    /// The URL of the reservation for this IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub address: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderPreservedStateInternalIp {
    /// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    #[builder(default)]
    pub auto_delete: Option<String>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    #[builder(default)]
    pub interface_name: Option<String>,
    /// Ip address representation
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default)]
    pub ip_address: Option<PerInstanceConfigInitProviderPreservedStateInternalIpIpAddress>,
}

/// Ip address representation
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderPreservedStateInternalIpIpAddress {
    /// The URL of the reservation for this IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub address: Option<String>,
}

/// Reference to a InstanceGroupManager in compute to populate zone.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderZoneRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigInitProviderZoneRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderZoneRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigInitProviderZoneRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigInitProviderZoneRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigInitProviderZoneRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigInitProviderZoneRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceGroupManager in compute to populate zone.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderZoneSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigInitProviderZoneSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigInitProviderZoneSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigInitProviderZoneSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigInitProviderZoneSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigInitProviderZoneSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigInitProviderZoneSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<PerInstanceConfigPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<PerInstanceConfigPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PerInstanceConfigPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PerInstanceConfigPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PerInstanceConfigPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PerInstanceConfigPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// PerInstanceConfigStatus defines the observed state of PerInstanceConfig.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<PerInstanceConfigStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigStatusAtProvider {
    /// an identifier for the resource with format {{project}}/{{zone}}/{{instance_group_manager}}/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The instance group manager this instance config is part of.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGroupManager")]
    #[builder(default)]
    pub instance_group_manager: Option<String>,
    /// The minimal action to perform on the instance during an update.
    /// Default is NONE. Possible values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimalAction")]
    #[builder(default)]
    pub minimal_action: Option<String>,
    /// The most disruptive action to perform on the instance during an update.
    /// Default is REPLACE. Possible values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mostDisruptiveAllowedAction")]
    #[builder(default)]
    pub most_disruptive_allowed_action: Option<String>,
    /// The name for this per-instance config and its corresponding instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The preserved state for this instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preservedState")]
    #[builder(default)]
    pub preserved_state: Option<PerInstanceConfigStatusAtProviderPreservedState>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// When true, deleting this config will immediately remove the underlying instance.
    /// When false, deleting this config will use the behavior as determined by remove_instance_on_destroy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeInstanceOnDestroy")]
    #[builder(default)]
    pub remove_instance_on_destroy: Option<bool>,
    /// When true, deleting this config will immediately remove any specified state from the underlying instance.
    /// When false, deleting this config will not immediately remove any state from the underlying instance.
    /// State will be removed on the next instance recreation or update.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeInstanceStateOnDestroy")]
    #[builder(default)]
    pub remove_instance_state_on_destroy: Option<bool>,
    /// Zone where the containing instance group manager is located
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub zone: Option<String>,
}

/// The preserved state for this instance.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigStatusAtProviderPreservedState {
    /// Stateful disks for the instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disk: Option<Vec<PerInstanceConfigStatusAtProviderPreservedStateDisk>>,
    /// Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIp")]
    #[builder(default)]
    pub external_ip: Option<Vec<PerInstanceConfigStatusAtProviderPreservedStateExternalIp>>,
    /// Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIp")]
    #[builder(default)]
    pub internal_ip: Option<Vec<PerInstanceConfigStatusAtProviderPreservedStateInternalIp>>,
    /// Preserved metadata defined for this instance. This is a list of key->value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigStatusAtProviderPreservedStateDisk {
    /// A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
    /// The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION.
    /// NEVER - detach the disk when the VM is deleted, but do not delete the disk.
    /// ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently
    /// deleted from the instance group.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    #[builder(default)]
    pub delete_rule: Option<String>,
    /// A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// The mode of the disk.
    /// Default value is READ_WRITE.
    /// Possible values are: READ_ONLY, READ_WRITE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
    /// The URI of an existing persistent disk to attach under the specified device-name in the format
    /// projects/project-id/zones/zone/disks/disk-name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigStatusAtProviderPreservedStateExternalIp {
    /// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    #[builder(default)]
    pub auto_delete: Option<String>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    #[builder(default)]
    pub interface_name: Option<String>,
    /// Ip address representation
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default)]
    pub ip_address: Option<PerInstanceConfigStatusAtProviderPreservedStateExternalIpIpAddress>,
}

/// Ip address representation
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigStatusAtProviderPreservedStateExternalIpIpAddress {
    /// The URL of the reservation for this IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub address: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigStatusAtProviderPreservedStateInternalIp {
    /// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    #[builder(default)]
    pub auto_delete: Option<String>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    #[builder(default)]
    pub interface_name: Option<String>,
    /// Ip address representation
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default)]
    pub ip_address: Option<PerInstanceConfigStatusAtProviderPreservedStateInternalIpIpAddress>,
}

/// Ip address representation
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PerInstanceConfigStatusAtProviderPreservedStateInternalIpIpAddress {
    /// The URL of the reservation for this IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub address: Option<String>,
}

