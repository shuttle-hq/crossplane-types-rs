// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// RegionInstanceGroupManagerSpec defines the desired state of RegionInstanceGroupManager
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta2", kind = "RegionInstanceGroupManager", plural = "regioninstancegroupmanagers")]
#[kube(status = "RegionInstanceGroupManagerStatus")]
pub struct RegionInstanceGroupManagerSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<RegionInstanceGroupManagerDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: RegionInstanceGroupManagerForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<RegionInstanceGroupManagerInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<RegionInstanceGroupManagerProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<RegionInstanceGroupManagerPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<RegionInstanceGroupManagerWriteConnectionSecretToRef>,
}

/// RegionInstanceGroupManagerSpec defines the desired state of RegionInstanceGroupManager
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProvider {
    /// Properties to set on all instances in the group. After setting
    /// allInstancesConfig on the group, you must update the group's instances to
    /// apply the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allInstancesConfig")]
    #[builder(default)]
    pub all_instances_config: Option<RegionInstanceGroupManagerForProviderAllInstancesConfig>,
    /// The autohealing policies for this managed instance
    /// group. You can specify only one value. Structure is documented below. For more information, see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoHealingPolicies")]
    #[builder(default)]
    pub auto_healing_policies: Option<RegionInstanceGroupManagerForProviderAutoHealingPolicies>,
    /// The base instance name to use for
    /// instances in this group. The value must be a valid
    /// RFC1035 name. Supported characters
    /// are lowercase letters, numbers, and hyphens (-). Instances are named by
    /// appending a hyphen and a random four-character string to the base instance
    /// name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseInstanceName")]
    #[builder(default)]
    pub base_instance_name: Option<String>,
    /// An optional textual description of the instance
    /// group manager.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The shape to which the group converges either proactively or on resize events (depending on the value set in update_policy.0.instance_redistribution_type). For more information see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "distributionPolicyTargetShape")]
    #[builder(default)]
    pub distribution_policy_target_shape: Option<String>,
    /// The distribution policy for this managed instance
    /// group. You can specify one or more values. For more information, see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "distributionPolicyZones")]
    #[builder(default)]
    pub distribution_policy_zones: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceLifecyclePolicy")]
    #[builder(default)]
    pub instance_lifecycle_policy: Option<RegionInstanceGroupManagerForProviderInstanceLifecyclePolicy>,
    /// Pagination behavior of the listManagedInstances API
    /// method for this managed instance group. Valid values are: PAGELESS, PAGINATED.
    /// If PAGELESS (default), Pagination is disabled for the group's listManagedInstances API method.
    /// maxResults and pageToken query parameters are ignored and all instances are returned in a single
    /// response. If PAGINATED, pagination is enabled, maxResults and pageToken query parameters are
    /// respected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "listManagedInstancesResults")]
    #[builder(default)]
    pub list_managed_instances_results: Option<String>,
    /// The name of the instance group manager. Must be 1-63
    /// characters long and comply with
    /// RFC1035. Supported characters
    /// include lowercase letters, numbers, and hyphens.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The named port configuration. See the section below
    /// for details on configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namedPort")]
    #[builder(default)]
    pub named_port: Option<Vec<RegionInstanceGroupManagerForProviderNamedPort>>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The region where the managed instance group resides. If not provided, the provider region is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    /// Disks created on the instances that will be preserved on instance delete, update, etc. Structure is documented below. For more information see the official documentation. Proactive cross zone instance redistribution must be disabled before you can update stateful disks on existing instance group managers. This can be controlled via the update_policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulDisk")]
    #[builder(default)]
    pub stateful_disk: Option<Vec<RegionInstanceGroupManagerForProviderStatefulDisk>>,
    /// External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulExternalIp")]
    #[builder(default)]
    pub stateful_external_ip: Option<Vec<RegionInstanceGroupManagerForProviderStatefulExternalIp>>,
    /// Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulInternalIp")]
    #[builder(default)]
    pub stateful_internal_ip: Option<Vec<RegionInstanceGroupManagerForProviderStatefulInternalIp>>,
    /// The full URL of all target pools to which new
    /// instances in the group are added. Updating the target pools attribute does
    /// not affect existing instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPools")]
    #[builder(default)]
    pub target_pools: Option<Vec<String>>,
    /// References to TargetPool in compute to populate targetPools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPoolsRefs")]
    #[builder(default)]
    pub target_pools_refs: Option<Vec<RegionInstanceGroupManagerForProviderTargetPoolsRefs>>,
    /// Selector for a list of TargetPool in compute to populate targetPools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPoolsSelector")]
    #[builder(default)]
    pub target_pools_selector: Option<RegionInstanceGroupManagerForProviderTargetPoolsSelector>,
    /// The target number of running instances for this managed
    /// instance group. This value will fight with autoscaler settings when set, and generally shouldn't be set
    /// when using one. If a value is required, such as to specify a creation-time target size for the MIG,
    /// lifecycle. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSize")]
    #[builder(default)]
    pub target_size: Option<f64>,
    /// The update policy for this managed instance group. Structure is documented below. For more information, see the official documentation and API
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatePolicy")]
    #[builder(default)]
    pub update_policy: Option<RegionInstanceGroupManagerForProviderUpdatePolicy>,
    /// Application versions managed by this instance group. Each
    /// version deals with a specific instance template, allowing canary release scenarios.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<Vec<RegionInstanceGroupManagerForProviderVersion>>,
    /// Whether to wait for all instances to be created/updated before
    /// returning.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForInstances")]
    #[builder(default)]
    pub wait_for_instances: Option<bool>,
    /// When used with wait_for_instances it specifies the status to wait for.
    /// When STABLE is specified this resource will wait until the instances are stable before returning. When UPDATED is
    /// set, it will wait for the version target to be reached and any per instance configs to be effective as well as all
    /// instances to be stable before returning. The possible values are STABLE and UPDATED
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForInstancesStatus")]
    #[builder(default)]
    pub wait_for_instances_status: Option<String>,
}

/// Properties to set on all instances in the group. After setting
/// allInstancesConfig on the group, you must update the group's instances to
/// apply the configuration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderAllInstancesConfig {
    /// , The label key-value pairs that you want to patch onto the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// , The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
}

/// The autohealing policies for this managed instance
/// group. You can specify only one value. Structure is documented below. For more information, see the official documentation.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderAutoHealingPolicies {
    /// The health check resource that signals autohealing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    #[builder(default)]
    pub health_check: Option<String>,
    /// Reference to a HealthCheck in compute to populate healthCheck.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckRef")]
    #[builder(default)]
    pub health_check_ref: Option<RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRef>,
    /// Selector for a HealthCheck in compute to populate healthCheck.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckSelector")]
    #[builder(default)]
    pub health_check_selector: Option<RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelector>,
    /// The number of seconds that the managed instance group waits before
    /// it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySec")]
    #[builder(default)]
    pub initial_delay_sec: Option<f64>,
}

/// Reference to a HealthCheck in compute to populate healthCheck.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a HealthCheck in compute to populate healthCheck.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderInstanceLifecyclePolicy {
    /// , Default behavior for all instance or health check failures. Valid options are: REPAIR, DO_NOTHING. If DO_NOTHING then instances will not be repaired. If REPAIR (default), then failed instances will be repaired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultActionOnFailure")]
    #[builder(default)]
    pub default_action_on_failure: Option<String>,
    /// , Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: YES, NO. If YES and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If NO (default), then updates are applied in accordance with the group's update policy type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceUpdateOnRepair")]
    #[builder(default)]
    pub force_update_on_repair: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderNamedPort {
    /// The name of the port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The port number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderStatefulDisk {
    /// , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the disk when the VM is deleted, but do not delete the disk. ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently deleted from the instance group. The default is NEVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    #[builder(default)]
    pub delete_rule: Option<String>,
    /// , The device name of the disk to be attached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderStatefulExternalIp {
    /// , A value that prescribes what should happen to the external ip when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the ip when the VM is deleted, but do not delete the ip. ON_PERMANENT_INSTANCE_DELETION will delete the external ip when the VM is permanently deleted from the instance group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    #[builder(default)]
    pub delete_rule: Option<String>,
    /// , The network interface name of the external Ip. Possible value: nic0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    #[builder(default)]
    pub interface_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderStatefulInternalIp {
    /// , A value that prescribes what should happen to the internal ip when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the ip when the VM is deleted, but do not delete the ip. ON_PERMANENT_INSTANCE_DELETION will delete the internal ip when the VM is permanently deleted from the instance group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    #[builder(default)]
    pub delete_rule: Option<String>,
    /// , The network interface name of the internal Ip. Possible value: nic0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    #[builder(default)]
    pub interface_name: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderTargetPoolsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerForProviderTargetPoolsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderTargetPoolsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerForProviderTargetPoolsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerForProviderTargetPoolsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerForProviderTargetPoolsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerForProviderTargetPoolsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of TargetPool in compute to populate targetPools.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderTargetPoolsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerForProviderTargetPoolsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderTargetPoolsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerForProviderTargetPoolsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerForProviderTargetPoolsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerForProviderTargetPoolsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerForProviderTargetPoolsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The update policy for this managed instance group. Structure is documented below. For more information, see the official documentation and API
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderUpdatePolicy {
    /// - The instance redistribution policy for regional managed instance groups. Valid values are: "PROACTIVE", "NONE". If PROACTIVE (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If NONE, proactive redistribution is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceRedistributionType")]
    #[builder(default)]
    pub instance_redistribution_type: Option<String>,
    /// , Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with max_surge_percent. Both cannot be 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurgeFixed")]
    #[builder(default)]
    pub max_surge_fixed: Option<f64>,
    /// , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with max_surge_fixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurgePercent")]
    #[builder(default)]
    pub max_surge_percent: Option<f64>,
    /// , Specifies a fixed number of VM instances. This must be a positive integer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailableFixed")]
    #[builder(default)]
    pub max_unavailable_fixed: Option<f64>,
    /// , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%..
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailablePercent")]
    #[builder(default)]
    pub max_unavailable_percent: Option<f64>,
    /// - Minimal action to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to update without stopping instances, RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a REFRESH, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimalAction")]
    #[builder(default)]
    pub minimal_action: Option<String>,
    /// - Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mostDisruptiveAllowedAction")]
    #[builder(default)]
    pub most_disruptive_allowed_action: Option<String>,
    /// , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementMethod")]
    #[builder(default)]
    pub replacement_method: Option<String>,
    /// - The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderVersion {
    /// - The full URL to an instance template from which all new instances of this version will be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplate")]
    #[builder(default)]
    pub instance_template: Option<String>,
    /// Reference to a InstanceTemplate in compute to populate instanceTemplate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplateRef")]
    #[builder(default)]
    pub instance_template_ref: Option<RegionInstanceGroupManagerForProviderVersionInstanceTemplateRef>,
    /// Selector for a InstanceTemplate in compute to populate instanceTemplate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplateSelector")]
    #[builder(default)]
    pub instance_template_selector: Option<RegionInstanceGroupManagerForProviderVersionInstanceTemplateSelector>,
    /// - Version name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSize")]
    #[builder(default)]
    pub target_size: Option<RegionInstanceGroupManagerForProviderVersionTargetSize>,
}

/// Reference to a InstanceTemplate in compute to populate instanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderVersionInstanceTemplateRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerForProviderVersionInstanceTemplateRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderVersionInstanceTemplateRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerForProviderVersionInstanceTemplateRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerForProviderVersionInstanceTemplateRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerForProviderVersionInstanceTemplateRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerForProviderVersionInstanceTemplateRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceTemplate in compute to populate instanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderVersionInstanceTemplateSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerForProviderVersionInstanceTemplateSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderVersionInstanceTemplateSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerForProviderVersionInstanceTemplateSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerForProviderVersionInstanceTemplateSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerForProviderVersionInstanceTemplateSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerForProviderVersionInstanceTemplateSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerForProviderVersionTargetSize {
    /// , The number of instances which are managed for this version. Conflicts with percent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fixed: Option<f64>,
    /// , The number of instances (calculated as percentage) which are managed for this version. Conflicts with fixed.
    /// Note that when using percent, rounding will be in favor of explicitly set target_size values; a managed instance group with 2 instances and 2 versions,
    /// one of which has a target_size.percent of 60 will create 2 instances of that version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percent: Option<f64>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProvider {
    /// Properties to set on all instances in the group. After setting
    /// allInstancesConfig on the group, you must update the group's instances to
    /// apply the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allInstancesConfig")]
    #[builder(default)]
    pub all_instances_config: Option<RegionInstanceGroupManagerInitProviderAllInstancesConfig>,
    /// The autohealing policies for this managed instance
    /// group. You can specify only one value. Structure is documented below. For more information, see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoHealingPolicies")]
    #[builder(default)]
    pub auto_healing_policies: Option<RegionInstanceGroupManagerInitProviderAutoHealingPolicies>,
    /// The base instance name to use for
    /// instances in this group. The value must be a valid
    /// RFC1035 name. Supported characters
    /// are lowercase letters, numbers, and hyphens (-). Instances are named by
    /// appending a hyphen and a random four-character string to the base instance
    /// name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseInstanceName")]
    #[builder(default)]
    pub base_instance_name: Option<String>,
    /// An optional textual description of the instance
    /// group manager.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The shape to which the group converges either proactively or on resize events (depending on the value set in update_policy.0.instance_redistribution_type). For more information see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "distributionPolicyTargetShape")]
    #[builder(default)]
    pub distribution_policy_target_shape: Option<String>,
    /// The distribution policy for this managed instance
    /// group. You can specify one or more values. For more information, see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "distributionPolicyZones")]
    #[builder(default)]
    pub distribution_policy_zones: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceLifecyclePolicy")]
    #[builder(default)]
    pub instance_lifecycle_policy: Option<RegionInstanceGroupManagerInitProviderInstanceLifecyclePolicy>,
    /// Pagination behavior of the listManagedInstances API
    /// method for this managed instance group. Valid values are: PAGELESS, PAGINATED.
    /// If PAGELESS (default), Pagination is disabled for the group's listManagedInstances API method.
    /// maxResults and pageToken query parameters are ignored and all instances are returned in a single
    /// response. If PAGINATED, pagination is enabled, maxResults and pageToken query parameters are
    /// respected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "listManagedInstancesResults")]
    #[builder(default)]
    pub list_managed_instances_results: Option<String>,
    /// The name of the instance group manager. Must be 1-63
    /// characters long and comply with
    /// RFC1035. Supported characters
    /// include lowercase letters, numbers, and hyphens.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The named port configuration. See the section below
    /// for details on configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namedPort")]
    #[builder(default)]
    pub named_port: Option<Vec<RegionInstanceGroupManagerInitProviderNamedPort>>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The region where the managed instance group resides. If not provided, the provider region is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    /// Disks created on the instances that will be preserved on instance delete, update, etc. Structure is documented below. For more information see the official documentation. Proactive cross zone instance redistribution must be disabled before you can update stateful disks on existing instance group managers. This can be controlled via the update_policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulDisk")]
    #[builder(default)]
    pub stateful_disk: Option<Vec<RegionInstanceGroupManagerInitProviderStatefulDisk>>,
    /// External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulExternalIp")]
    #[builder(default)]
    pub stateful_external_ip: Option<Vec<RegionInstanceGroupManagerInitProviderStatefulExternalIp>>,
    /// Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulInternalIp")]
    #[builder(default)]
    pub stateful_internal_ip: Option<Vec<RegionInstanceGroupManagerInitProviderStatefulInternalIp>>,
    /// The full URL of all target pools to which new
    /// instances in the group are added. Updating the target pools attribute does
    /// not affect existing instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPools")]
    #[builder(default)]
    pub target_pools: Option<Vec<String>>,
    /// References to TargetPool in compute to populate targetPools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPoolsRefs")]
    #[builder(default)]
    pub target_pools_refs: Option<Vec<RegionInstanceGroupManagerInitProviderTargetPoolsRefs>>,
    /// Selector for a list of TargetPool in compute to populate targetPools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPoolsSelector")]
    #[builder(default)]
    pub target_pools_selector: Option<RegionInstanceGroupManagerInitProviderTargetPoolsSelector>,
    /// The target number of running instances for this managed
    /// instance group. This value will fight with autoscaler settings when set, and generally shouldn't be set
    /// when using one. If a value is required, such as to specify a creation-time target size for the MIG,
    /// lifecycle. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSize")]
    #[builder(default)]
    pub target_size: Option<f64>,
    /// The update policy for this managed instance group. Structure is documented below. For more information, see the official documentation and API
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatePolicy")]
    #[builder(default)]
    pub update_policy: Option<RegionInstanceGroupManagerInitProviderUpdatePolicy>,
    /// Application versions managed by this instance group. Each
    /// version deals with a specific instance template, allowing canary release scenarios.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<Vec<RegionInstanceGroupManagerInitProviderVersion>>,
    /// Whether to wait for all instances to be created/updated before
    /// returning.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForInstances")]
    #[builder(default)]
    pub wait_for_instances: Option<bool>,
    /// When used with wait_for_instances it specifies the status to wait for.
    /// When STABLE is specified this resource will wait until the instances are stable before returning. When UPDATED is
    /// set, it will wait for the version target to be reached and any per instance configs to be effective as well as all
    /// instances to be stable before returning. The possible values are STABLE and UPDATED
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForInstancesStatus")]
    #[builder(default)]
    pub wait_for_instances_status: Option<String>,
}

/// Properties to set on all instances in the group. After setting
/// allInstancesConfig on the group, you must update the group's instances to
/// apply the configuration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderAllInstancesConfig {
    /// , The label key-value pairs that you want to patch onto the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// , The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
}

/// The autohealing policies for this managed instance
/// group. You can specify only one value. Structure is documented below. For more information, see the official documentation.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderAutoHealingPolicies {
    /// The health check resource that signals autohealing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    #[builder(default)]
    pub health_check: Option<String>,
    /// Reference to a HealthCheck in compute to populate healthCheck.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckRef")]
    #[builder(default)]
    pub health_check_ref: Option<RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRef>,
    /// Selector for a HealthCheck in compute to populate healthCheck.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckSelector")]
    #[builder(default)]
    pub health_check_selector: Option<RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelector>,
    /// The number of seconds that the managed instance group waits before
    /// it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySec")]
    #[builder(default)]
    pub initial_delay_sec: Option<f64>,
}

/// Reference to a HealthCheck in compute to populate healthCheck.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a HealthCheck in compute to populate healthCheck.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderInstanceLifecyclePolicy {
    /// , Default behavior for all instance or health check failures. Valid options are: REPAIR, DO_NOTHING. If DO_NOTHING then instances will not be repaired. If REPAIR (default), then failed instances will be repaired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultActionOnFailure")]
    #[builder(default)]
    pub default_action_on_failure: Option<String>,
    /// , Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: YES, NO. If YES and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If NO (default), then updates are applied in accordance with the group's update policy type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceUpdateOnRepair")]
    #[builder(default)]
    pub force_update_on_repair: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderNamedPort {
    /// The name of the port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The port number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderStatefulDisk {
    /// , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the disk when the VM is deleted, but do not delete the disk. ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently deleted from the instance group. The default is NEVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    #[builder(default)]
    pub delete_rule: Option<String>,
    /// , The device name of the disk to be attached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderStatefulExternalIp {
    /// , A value that prescribes what should happen to the external ip when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the ip when the VM is deleted, but do not delete the ip. ON_PERMANENT_INSTANCE_DELETION will delete the external ip when the VM is permanently deleted from the instance group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    #[builder(default)]
    pub delete_rule: Option<String>,
    /// , The network interface name of the external Ip. Possible value: nic0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    #[builder(default)]
    pub interface_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderStatefulInternalIp {
    /// , A value that prescribes what should happen to the internal ip when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the ip when the VM is deleted, but do not delete the ip. ON_PERMANENT_INSTANCE_DELETION will delete the internal ip when the VM is permanently deleted from the instance group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    #[builder(default)]
    pub delete_rule: Option<String>,
    /// , The network interface name of the internal Ip. Possible value: nic0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    #[builder(default)]
    pub interface_name: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderTargetPoolsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerInitProviderTargetPoolsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderTargetPoolsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerInitProviderTargetPoolsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerInitProviderTargetPoolsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerInitProviderTargetPoolsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerInitProviderTargetPoolsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of TargetPool in compute to populate targetPools.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderTargetPoolsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerInitProviderTargetPoolsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderTargetPoolsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerInitProviderTargetPoolsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerInitProviderTargetPoolsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerInitProviderTargetPoolsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerInitProviderTargetPoolsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The update policy for this managed instance group. Structure is documented below. For more information, see the official documentation and API
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderUpdatePolicy {
    /// - The instance redistribution policy for regional managed instance groups. Valid values are: "PROACTIVE", "NONE". If PROACTIVE (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If NONE, proactive redistribution is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceRedistributionType")]
    #[builder(default)]
    pub instance_redistribution_type: Option<String>,
    /// , Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with max_surge_percent. Both cannot be 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurgeFixed")]
    #[builder(default)]
    pub max_surge_fixed: Option<f64>,
    /// , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with max_surge_fixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurgePercent")]
    #[builder(default)]
    pub max_surge_percent: Option<f64>,
    /// , Specifies a fixed number of VM instances. This must be a positive integer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailableFixed")]
    #[builder(default)]
    pub max_unavailable_fixed: Option<f64>,
    /// , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%..
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailablePercent")]
    #[builder(default)]
    pub max_unavailable_percent: Option<f64>,
    /// - Minimal action to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to update without stopping instances, RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a REFRESH, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimalAction")]
    #[builder(default)]
    pub minimal_action: Option<String>,
    /// - Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mostDisruptiveAllowedAction")]
    #[builder(default)]
    pub most_disruptive_allowed_action: Option<String>,
    /// , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementMethod")]
    #[builder(default)]
    pub replacement_method: Option<String>,
    /// - The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderVersion {
    /// - The full URL to an instance template from which all new instances of this version will be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplate")]
    #[builder(default)]
    pub instance_template: Option<String>,
    /// Reference to a InstanceTemplate in compute to populate instanceTemplate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplateRef")]
    #[builder(default)]
    pub instance_template_ref: Option<RegionInstanceGroupManagerInitProviderVersionInstanceTemplateRef>,
    /// Selector for a InstanceTemplate in compute to populate instanceTemplate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplateSelector")]
    #[builder(default)]
    pub instance_template_selector: Option<RegionInstanceGroupManagerInitProviderVersionInstanceTemplateSelector>,
    /// - Version name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSize")]
    #[builder(default)]
    pub target_size: Option<RegionInstanceGroupManagerInitProviderVersionTargetSize>,
}

/// Reference to a InstanceTemplate in compute to populate instanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderVersionInstanceTemplateRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerInitProviderVersionInstanceTemplateRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderVersionInstanceTemplateRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerInitProviderVersionInstanceTemplateRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerInitProviderVersionInstanceTemplateRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerInitProviderVersionInstanceTemplateRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerInitProviderVersionInstanceTemplateRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceTemplate in compute to populate instanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderVersionInstanceTemplateSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerInitProviderVersionInstanceTemplateSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderVersionInstanceTemplateSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerInitProviderVersionInstanceTemplateSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerInitProviderVersionInstanceTemplateSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerInitProviderVersionInstanceTemplateSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerInitProviderVersionInstanceTemplateSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerInitProviderVersionTargetSize {
    /// , The number of instances which are managed for this version. Conflicts with percent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fixed: Option<f64>,
    /// , The number of instances (calculated as percentage) which are managed for this version. Conflicts with fixed.
    /// Note that when using percent, rounding will be in favor of explicitly set target_size values; a managed instance group with 2 instances and 2 versions,
    /// one of which has a target_size.percent of 60 will create 2 instances of that version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percent: Option<f64>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<RegionInstanceGroupManagerPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<RegionInstanceGroupManagerPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionInstanceGroupManagerPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionInstanceGroupManagerPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionInstanceGroupManagerPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionInstanceGroupManagerPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// RegionInstanceGroupManagerStatus defines the observed state of RegionInstanceGroupManager.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<RegionInstanceGroupManagerStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProvider {
    /// Properties to set on all instances in the group. After setting
    /// allInstancesConfig on the group, you must update the group's instances to
    /// apply the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allInstancesConfig")]
    #[builder(default)]
    pub all_instances_config: Option<RegionInstanceGroupManagerStatusAtProviderAllInstancesConfig>,
    /// The autohealing policies for this managed instance
    /// group. You can specify only one value. Structure is documented below. For more information, see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoHealingPolicies")]
    #[builder(default)]
    pub auto_healing_policies: Option<RegionInstanceGroupManagerStatusAtProviderAutoHealingPolicies>,
    /// The base instance name to use for
    /// instances in this group. The value must be a valid
    /// RFC1035 name. Supported characters
    /// are lowercase letters, numbers, and hyphens (-). Instances are named by
    /// appending a hyphen and a random four-character string to the base instance
    /// name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseInstanceName")]
    #[builder(default)]
    pub base_instance_name: Option<String>,
    /// Creation timestamp in RFC3339 text format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationTimestamp")]
    #[builder(default)]
    pub creation_timestamp: Option<String>,
    /// An optional textual description of the instance
    /// group manager.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The shape to which the group converges either proactively or on resize events (depending on the value set in update_policy.0.instance_redistribution_type). For more information see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "distributionPolicyTargetShape")]
    #[builder(default)]
    pub distribution_policy_target_shape: Option<String>,
    /// The distribution policy for this managed instance
    /// group. You can specify one or more values. For more information, see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "distributionPolicyZones")]
    #[builder(default)]
    pub distribution_policy_zones: Option<Vec<String>>,
    /// The fingerprint of the instance group manager.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fingerprint: Option<String>,
    /// an identifier for the resource with format projects/{{project}}/regions/{{region}}/instanceGroupManagers/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The full URL of the instance group created by the manager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGroup")]
    #[builder(default)]
    pub instance_group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceLifecyclePolicy")]
    #[builder(default)]
    pub instance_lifecycle_policy: Option<RegionInstanceGroupManagerStatusAtProviderInstanceLifecyclePolicy>,
    /// Pagination behavior of the listManagedInstances API
    /// method for this managed instance group. Valid values are: PAGELESS, PAGINATED.
    /// If PAGELESS (default), Pagination is disabled for the group's listManagedInstances API method.
    /// maxResults and pageToken query parameters are ignored and all instances are returned in a single
    /// response. If PAGINATED, pagination is enabled, maxResults and pageToken query parameters are
    /// respected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "listManagedInstancesResults")]
    #[builder(default)]
    pub list_managed_instances_results: Option<String>,
    /// The name of the instance group manager. Must be 1-63
    /// characters long and comply with
    /// RFC1035. Supported characters
    /// include lowercase letters, numbers, and hyphens.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The named port configuration. See the section below
    /// for details on configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namedPort")]
    #[builder(default)]
    pub named_port: Option<Vec<RegionInstanceGroupManagerStatusAtProviderNamedPort>>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The region where the managed instance group resides. If not provided, the provider region is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    /// The URL of the created resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLink")]
    #[builder(default)]
    pub self_link: Option<String>,
    /// Disks created on the instances that will be preserved on instance delete, update, etc. Structure is documented below. For more information see the official documentation. Proactive cross zone instance redistribution must be disabled before you can update stateful disks on existing instance group managers. This can be controlled via the update_policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulDisk")]
    #[builder(default)]
    pub stateful_disk: Option<Vec<RegionInstanceGroupManagerStatusAtProviderStatefulDisk>>,
    /// External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulExternalIp")]
    #[builder(default)]
    pub stateful_external_ip: Option<Vec<RegionInstanceGroupManagerStatusAtProviderStatefulExternalIp>>,
    /// Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulInternalIp")]
    #[builder(default)]
    pub stateful_internal_ip: Option<Vec<RegionInstanceGroupManagerStatusAtProviderStatefulInternalIp>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub status: Option<Vec<RegionInstanceGroupManagerStatusAtProviderStatus>>,
    /// The full URL of all target pools to which new
    /// instances in the group are added. Updating the target pools attribute does
    /// not affect existing instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPools")]
    #[builder(default)]
    pub target_pools: Option<Vec<String>>,
    /// The target number of running instances for this managed
    /// instance group. This value will fight with autoscaler settings when set, and generally shouldn't be set
    /// when using one. If a value is required, such as to specify a creation-time target size for the MIG,
    /// lifecycle. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSize")]
    #[builder(default)]
    pub target_size: Option<f64>,
    /// The update policy for this managed instance group. Structure is documented below. For more information, see the official documentation and API
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatePolicy")]
    #[builder(default)]
    pub update_policy: Option<RegionInstanceGroupManagerStatusAtProviderUpdatePolicy>,
    /// Application versions managed by this instance group. Each
    /// version deals with a specific instance template, allowing canary release scenarios.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<Vec<RegionInstanceGroupManagerStatusAtProviderVersion>>,
    /// Whether to wait for all instances to be created/updated before
    /// returning.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForInstances")]
    #[builder(default)]
    pub wait_for_instances: Option<bool>,
    /// When used with wait_for_instances it specifies the status to wait for.
    /// When STABLE is specified this resource will wait until the instances are stable before returning. When UPDATED is
    /// set, it will wait for the version target to be reached and any per instance configs to be effective as well as all
    /// instances to be stable before returning. The possible values are STABLE and UPDATED
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForInstancesStatus")]
    #[builder(default)]
    pub wait_for_instances_status: Option<String>,
}

/// Properties to set on all instances in the group. After setting
/// allInstancesConfig on the group, you must update the group's instances to
/// apply the configuration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderAllInstancesConfig {
    /// , The label key-value pairs that you want to patch onto the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// , The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
}

/// The autohealing policies for this managed instance
/// group. You can specify only one value. Structure is documented below. For more information, see the official documentation.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderAutoHealingPolicies {
    /// The health check resource that signals autohealing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    #[builder(default)]
    pub health_check: Option<String>,
    /// The number of seconds that the managed instance group waits before
    /// it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySec")]
    #[builder(default)]
    pub initial_delay_sec: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderInstanceLifecyclePolicy {
    /// , Default behavior for all instance or health check failures. Valid options are: REPAIR, DO_NOTHING. If DO_NOTHING then instances will not be repaired. If REPAIR (default), then failed instances will be repaired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultActionOnFailure")]
    #[builder(default)]
    pub default_action_on_failure: Option<String>,
    /// , Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: YES, NO. If YES and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If NO (default), then updates are applied in accordance with the group's update policy type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceUpdateOnRepair")]
    #[builder(default)]
    pub force_update_on_repair: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderNamedPort {
    /// The name of the port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The port number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderStatefulDisk {
    /// , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the disk when the VM is deleted, but do not delete the disk. ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently deleted from the instance group. The default is NEVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    #[builder(default)]
    pub delete_rule: Option<String>,
    /// , The device name of the disk to be attached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderStatefulExternalIp {
    /// , A value that prescribes what should happen to the external ip when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the ip when the VM is deleted, but do not delete the ip. ON_PERMANENT_INSTANCE_DELETION will delete the external ip when the VM is permanently deleted from the instance group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    #[builder(default)]
    pub delete_rule: Option<String>,
    /// , The network interface name of the external Ip. Possible value: nic0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    #[builder(default)]
    pub interface_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderStatefulInternalIp {
    /// , A value that prescribes what should happen to the internal ip when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the ip when the VM is deleted, but do not delete the ip. ON_PERMANENT_INSTANCE_DELETION will delete the internal ip when the VM is permanently deleted from the instance group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    #[builder(default)]
    pub delete_rule: Option<String>,
    /// , The network interface name of the internal Ip. Possible value: nic0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    #[builder(default)]
    pub interface_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderStatus {
    /// Status of all-instances configuration on the group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allInstancesConfig")]
    #[builder(default)]
    pub all_instances_config: Option<Vec<RegionInstanceGroupManagerStatusAtProviderStatusAllInstancesConfig>>,
    /// A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isStable")]
    #[builder(default)]
    pub is_stable: Option<bool>,
    /// Stateful status of the given Instance Group Manager.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stateful: Option<Vec<RegionInstanceGroupManagerStatusAtProviderStatusStateful>>,
    /// A status of consistency of Instances' versions with their target version specified by version field on Instance Group Manager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionTarget")]
    #[builder(default)]
    pub version_target: Option<Vec<RegionInstanceGroupManagerStatusAtProviderStatusVersionTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderStatusAllInstancesConfig {
    /// Current all-instances configuration revision. This value is in RFC3339 text format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "currentRevision")]
    #[builder(default)]
    pub current_revision: Option<String>,
    /// A bit indicating whether this configuration has been applied to all managed instances in the group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub effective: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderStatusStateful {
    /// A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hasStatefulConfig")]
    #[builder(default)]
    pub has_stateful_config: Option<bool>,
    /// Status of per-instance configs on the instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perInstanceConfigs")]
    #[builder(default)]
    pub per_instance_configs: Option<Vec<RegionInstanceGroupManagerStatusAtProviderStatusStatefulPerInstanceConfigs>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderStatusStatefulPerInstanceConfigs {
    /// A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status EFFECTIVE or there are no per-instance-configs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allEffective")]
    #[builder(default)]
    pub all_effective: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderStatusVersionTarget {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isReached")]
    #[builder(default)]
    pub is_reached: Option<bool>,
}

/// The update policy for this managed instance group. Structure is documented below. For more information, see the official documentation and API
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderUpdatePolicy {
    /// - The instance redistribution policy for regional managed instance groups. Valid values are: "PROACTIVE", "NONE". If PROACTIVE (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If NONE, proactive redistribution is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceRedistributionType")]
    #[builder(default)]
    pub instance_redistribution_type: Option<String>,
    /// , Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with max_surge_percent. Both cannot be 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurgeFixed")]
    #[builder(default)]
    pub max_surge_fixed: Option<f64>,
    /// , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with max_surge_fixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurgePercent")]
    #[builder(default)]
    pub max_surge_percent: Option<f64>,
    /// , Specifies a fixed number of VM instances. This must be a positive integer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailableFixed")]
    #[builder(default)]
    pub max_unavailable_fixed: Option<f64>,
    /// , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%..
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailablePercent")]
    #[builder(default)]
    pub max_unavailable_percent: Option<f64>,
    /// - Minimal action to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to update without stopping instances, RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a REFRESH, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimalAction")]
    #[builder(default)]
    pub minimal_action: Option<String>,
    /// - Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mostDisruptiveAllowedAction")]
    #[builder(default)]
    pub most_disruptive_allowed_action: Option<String>,
    /// , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementMethod")]
    #[builder(default)]
    pub replacement_method: Option<String>,
    /// - The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderVersion {
    /// - The full URL to an instance template from which all new instances of this version will be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplate")]
    #[builder(default)]
    pub instance_template: Option<String>,
    /// - Version name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSize")]
    #[builder(default)]
    pub target_size: Option<RegionInstanceGroupManagerStatusAtProviderVersionTargetSize>,
}

/// - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionInstanceGroupManagerStatusAtProviderVersionTargetSize {
    /// , The number of instances which are managed for this version. Conflicts with percent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fixed: Option<f64>,
    /// , The number of instances (calculated as percentage) which are managed for this version. Conflicts with fixed.
    /// Note that when using percent, rounding will be in favor of explicitly set target_size values; a managed instance group with 2 instances and 2 versions,
    /// one of which has a target_size.percent of 60 will create 2 instances of that version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percent: Option<f64>,
}

