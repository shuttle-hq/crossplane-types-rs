// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// InterconnectAttachmentSpec defines the desired state of InterconnectAttachment
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta1", kind = "InterconnectAttachment", plural = "interconnectattachments")]
#[kube(status = "InterconnectAttachmentStatus")]
pub struct InterconnectAttachmentSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<InterconnectAttachmentDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: InterconnectAttachmentForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<InterconnectAttachmentInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<InterconnectAttachmentProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<InterconnectAttachmentPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<InterconnectAttachmentWriteConnectionSecretToRef>,
}

/// InterconnectAttachmentSpec defines the desired state of InterconnectAttachment
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentForProvider {
    /// Whether the VLAN attachment is enabled or disabled.  When using
    /// PARTNER type this will Pre-Activate the interconnect attachment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminEnabled")]
    #[builder(default)]
    pub admin_enabled: Option<bool>,
    /// Provisioned bandwidth capacity for the interconnect attachment.
    /// For attachments of type DEDICATED, the user can set the bandwidth.
    /// For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth.
    /// Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED,
    /// Defaults to BPS_10G
    /// Possible values are: BPS_50M, BPS_100M, BPS_200M, BPS_300M, BPS_400M, BPS_500M, BPS_1G, BPS_2G, BPS_5G, BPS_10G, BPS_20G, BPS_50G.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bandwidth: Option<String>,
    /// Up to 16 candidate prefixes that can be used to restrict the allocation
    /// of cloudRouterIpAddress and customerRouterIpAddress for this attachment.
    /// All prefixes must be within link-local address space (169.254.0.0/16)
    /// and must be /29 or shorter (/28, /27, etc). Google will attempt to select
    /// an unused /29 from the supplied candidate prefix(es). The request will
    /// fail if all possible /29s are in use on Google's edge. If not supplied,
    /// Google will randomly select an unused /29 from all of link-local space.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "candidateSubnets")]
    #[builder(default)]
    pub candidate_subnets: Option<Vec<String>>,
    /// An optional description of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Desired availability domain for the attachment. Only available for type
    /// PARTNER, at creation time. For improved reliability, customers should
    /// configure a pair of attachments with one per availability domain. The
    /// selected availability domain will be provided to the Partner via the
    /// pairing key so that the provisioned circuit will lie in the specified
    /// domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "edgeAvailabilityDomain")]
    #[builder(default)]
    pub edge_availability_domain: Option<String>,
    /// Indicates the user-supplied encryption option of this interconnect
    /// attachment. Can only be specified at attachment creation for PARTNER or
    /// DEDICATED attachments.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encryption: Option<String>,
    /// URL of the underlying Interconnect object that this attachment's
    /// traffic will traverse through. Required if type is DEDICATED, must not
    /// be set if type is PARTNER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub interconnect: Option<String>,
    /// URL of addresses that have been reserved for the interconnect attachment,
    /// Used only for interconnect attachment that has the encryption option as
    /// IPSEC.
    /// The addresses must be RFC 1918 IP address ranges. When creating HA VPN
    /// gateway over the interconnect attachment, if the attachment is configured
    /// to use an RFC 1918 IP address, then the VPN gateway's IP address will be
    /// allocated from the IP address range specified here.
    /// For example, if the HA VPN gateway's interface 0 is paired to this
    /// interconnect attachment, then an RFC 1918 IP address for the VPN gateway
    /// interface 0 will be allocated from the IP address specified for this
    /// interconnect attachment.
    /// If this field is not specified for interconnect attachment that has
    /// encryption option as IPSEC, later on when creating HA VPN gateway on this
    /// interconnect attachment, the HA VPN gateway's IP address will be
    /// allocated from regional external IP address pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipsecInternalAddresses")]
    #[builder(default)]
    pub ipsec_internal_addresses: Option<Vec<String>>,
    /// References to Address in compute to populate ipsecInternalAddresses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipsecInternalAddressesRefs")]
    #[builder(default)]
    pub ipsec_internal_addresses_refs: Option<Vec<InterconnectAttachmentForProviderIpsecInternalAddressesRefs>>,
    /// Selector for a list of Address in compute to populate ipsecInternalAddresses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipsecInternalAddressesSelector")]
    #[builder(default)]
    pub ipsec_internal_addresses_selector: Option<InterconnectAttachmentForProviderIpsecInternalAddressesSelector>,
    /// Maximum Transmission Unit (MTU), in bytes, of packets passing through
    /// this interconnect attachment. Currently, only 1440 and 1500 are allowed. If not specified, the value will default to 1440.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mtu: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Region where the regional interconnect attachment resides.
    pub region: String,
    /// URL of the cloud router to be used for dynamic routing. This router must be in
    /// the same region as this InterconnectAttachment. The InterconnectAttachment will
    /// automatically connect the Interconnect to the network & region within which the
    /// Cloud Router is configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub router: Option<String>,
    /// Reference to a Router in compute to populate router.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routerRef")]
    #[builder(default)]
    pub router_ref: Option<InterconnectAttachmentForProviderRouterRef>,
    /// Selector for a Router in compute to populate router.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routerSelector")]
    #[builder(default)]
    pub router_selector: Option<InterconnectAttachmentForProviderRouterSelector>,
    /// The stack type for this interconnect attachment to identify whether the IPv6
    /// feature is enabled or not. If not specified, IPV4_ONLY will be used.
    /// This field can be both set at interconnect attachments creation and update
    /// interconnect attachment operations.
    /// Possible values are: IPV4_IPV6, IPV4_ONLY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    #[builder(default)]
    pub stack_type: Option<String>,
    /// Length of the IPv4 subnet mask. Allowed values: 29 (default), 30. The default value is 29,
    /// except for Cross-Cloud Interconnect connections that use an InterconnectRemoteLocation with a
    /// constraints.subnetLengthRange.min equal to 30. For example, connections that use an Azure
    /// remote location fall into this category. In these cases, the default value is 30, and
    /// requesting 29 returns an error. Where both 29 and 30 are allowed, 29 is preferred, because it
    /// gives Google Cloud Support more debugging visibility.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetLength")]
    #[builder(default)]
    pub subnet_length: Option<f64>,
    /// The type of InterconnectAttachment you wish to create. Defaults to
    /// DEDICATED.
    /// Possible values are: DEDICATED, PARTNER, PARTNER_PROVIDER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
    /// The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. When
    /// using PARTNER type this will be managed upstream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vlanTag8021Q")]
    #[builder(default)]
    pub vlan_tag8021_q: Option<f64>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentForProviderIpsecInternalAddressesRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InterconnectAttachmentForProviderIpsecInternalAddressesRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentForProviderIpsecInternalAddressesRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InterconnectAttachmentForProviderIpsecInternalAddressesRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InterconnectAttachmentForProviderIpsecInternalAddressesRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentForProviderIpsecInternalAddressesRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentForProviderIpsecInternalAddressesRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Address in compute to populate ipsecInternalAddresses.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentForProviderIpsecInternalAddressesSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InterconnectAttachmentForProviderIpsecInternalAddressesSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentForProviderIpsecInternalAddressesSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InterconnectAttachmentForProviderIpsecInternalAddressesSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InterconnectAttachmentForProviderIpsecInternalAddressesSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentForProviderIpsecInternalAddressesSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentForProviderIpsecInternalAddressesSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Router in compute to populate router.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentForProviderRouterRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InterconnectAttachmentForProviderRouterRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentForProviderRouterRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InterconnectAttachmentForProviderRouterRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InterconnectAttachmentForProviderRouterRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentForProviderRouterRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentForProviderRouterRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Router in compute to populate router.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentForProviderRouterSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InterconnectAttachmentForProviderRouterSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentForProviderRouterSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InterconnectAttachmentForProviderRouterSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InterconnectAttachmentForProviderRouterSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentForProviderRouterSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentForProviderRouterSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentInitProvider {
    /// Whether the VLAN attachment is enabled or disabled.  When using
    /// PARTNER type this will Pre-Activate the interconnect attachment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminEnabled")]
    #[builder(default)]
    pub admin_enabled: Option<bool>,
    /// Provisioned bandwidth capacity for the interconnect attachment.
    /// For attachments of type DEDICATED, the user can set the bandwidth.
    /// For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth.
    /// Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED,
    /// Defaults to BPS_10G
    /// Possible values are: BPS_50M, BPS_100M, BPS_200M, BPS_300M, BPS_400M, BPS_500M, BPS_1G, BPS_2G, BPS_5G, BPS_10G, BPS_20G, BPS_50G.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bandwidth: Option<String>,
    /// Up to 16 candidate prefixes that can be used to restrict the allocation
    /// of cloudRouterIpAddress and customerRouterIpAddress for this attachment.
    /// All prefixes must be within link-local address space (169.254.0.0/16)
    /// and must be /29 or shorter (/28, /27, etc). Google will attempt to select
    /// an unused /29 from the supplied candidate prefix(es). The request will
    /// fail if all possible /29s are in use on Google's edge. If not supplied,
    /// Google will randomly select an unused /29 from all of link-local space.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "candidateSubnets")]
    #[builder(default)]
    pub candidate_subnets: Option<Vec<String>>,
    /// An optional description of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Desired availability domain for the attachment. Only available for type
    /// PARTNER, at creation time. For improved reliability, customers should
    /// configure a pair of attachments with one per availability domain. The
    /// selected availability domain will be provided to the Partner via the
    /// pairing key so that the provisioned circuit will lie in the specified
    /// domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "edgeAvailabilityDomain")]
    #[builder(default)]
    pub edge_availability_domain: Option<String>,
    /// Indicates the user-supplied encryption option of this interconnect
    /// attachment. Can only be specified at attachment creation for PARTNER or
    /// DEDICATED attachments.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encryption: Option<String>,
    /// URL of the underlying Interconnect object that this attachment's
    /// traffic will traverse through. Required if type is DEDICATED, must not
    /// be set if type is PARTNER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub interconnect: Option<String>,
    /// URL of addresses that have been reserved for the interconnect attachment,
    /// Used only for interconnect attachment that has the encryption option as
    /// IPSEC.
    /// The addresses must be RFC 1918 IP address ranges. When creating HA VPN
    /// gateway over the interconnect attachment, if the attachment is configured
    /// to use an RFC 1918 IP address, then the VPN gateway's IP address will be
    /// allocated from the IP address range specified here.
    /// For example, if the HA VPN gateway's interface 0 is paired to this
    /// interconnect attachment, then an RFC 1918 IP address for the VPN gateway
    /// interface 0 will be allocated from the IP address specified for this
    /// interconnect attachment.
    /// If this field is not specified for interconnect attachment that has
    /// encryption option as IPSEC, later on when creating HA VPN gateway on this
    /// interconnect attachment, the HA VPN gateway's IP address will be
    /// allocated from regional external IP address pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipsecInternalAddresses")]
    #[builder(default)]
    pub ipsec_internal_addresses: Option<Vec<String>>,
    /// References to Address in compute to populate ipsecInternalAddresses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipsecInternalAddressesRefs")]
    #[builder(default)]
    pub ipsec_internal_addresses_refs: Option<Vec<InterconnectAttachmentInitProviderIpsecInternalAddressesRefs>>,
    /// Selector for a list of Address in compute to populate ipsecInternalAddresses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipsecInternalAddressesSelector")]
    #[builder(default)]
    pub ipsec_internal_addresses_selector: Option<InterconnectAttachmentInitProviderIpsecInternalAddressesSelector>,
    /// Maximum Transmission Unit (MTU), in bytes, of packets passing through
    /// this interconnect attachment. Currently, only 1440 and 1500 are allowed. If not specified, the value will default to 1440.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mtu: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// URL of the cloud router to be used for dynamic routing. This router must be in
    /// the same region as this InterconnectAttachment. The InterconnectAttachment will
    /// automatically connect the Interconnect to the network & region within which the
    /// Cloud Router is configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub router: Option<String>,
    /// Reference to a Router in compute to populate router.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routerRef")]
    #[builder(default)]
    pub router_ref: Option<InterconnectAttachmentInitProviderRouterRef>,
    /// Selector for a Router in compute to populate router.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routerSelector")]
    #[builder(default)]
    pub router_selector: Option<InterconnectAttachmentInitProviderRouterSelector>,
    /// The stack type for this interconnect attachment to identify whether the IPv6
    /// feature is enabled or not. If not specified, IPV4_ONLY will be used.
    /// This field can be both set at interconnect attachments creation and update
    /// interconnect attachment operations.
    /// Possible values are: IPV4_IPV6, IPV4_ONLY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    #[builder(default)]
    pub stack_type: Option<String>,
    /// Length of the IPv4 subnet mask. Allowed values: 29 (default), 30. The default value is 29,
    /// except for Cross-Cloud Interconnect connections that use an InterconnectRemoteLocation with a
    /// constraints.subnetLengthRange.min equal to 30. For example, connections that use an Azure
    /// remote location fall into this category. In these cases, the default value is 30, and
    /// requesting 29 returns an error. Where both 29 and 30 are allowed, 29 is preferred, because it
    /// gives Google Cloud Support more debugging visibility.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetLength")]
    #[builder(default)]
    pub subnet_length: Option<f64>,
    /// The type of InterconnectAttachment you wish to create. Defaults to
    /// DEDICATED.
    /// Possible values are: DEDICATED, PARTNER, PARTNER_PROVIDER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
    /// The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. When
    /// using PARTNER type this will be managed upstream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vlanTag8021Q")]
    #[builder(default)]
    pub vlan_tag8021_q: Option<f64>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentInitProviderIpsecInternalAddressesRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InterconnectAttachmentInitProviderIpsecInternalAddressesRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentInitProviderIpsecInternalAddressesRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InterconnectAttachmentInitProviderIpsecInternalAddressesRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InterconnectAttachmentInitProviderIpsecInternalAddressesRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentInitProviderIpsecInternalAddressesRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentInitProviderIpsecInternalAddressesRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Address in compute to populate ipsecInternalAddresses.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentInitProviderIpsecInternalAddressesSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InterconnectAttachmentInitProviderIpsecInternalAddressesSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentInitProviderIpsecInternalAddressesSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InterconnectAttachmentInitProviderIpsecInternalAddressesSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InterconnectAttachmentInitProviderIpsecInternalAddressesSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentInitProviderIpsecInternalAddressesSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentInitProviderIpsecInternalAddressesSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Router in compute to populate router.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentInitProviderRouterRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InterconnectAttachmentInitProviderRouterRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentInitProviderRouterRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InterconnectAttachmentInitProviderRouterRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InterconnectAttachmentInitProviderRouterRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentInitProviderRouterRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentInitProviderRouterRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Router in compute to populate router.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentInitProviderRouterSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InterconnectAttachmentInitProviderRouterSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentInitProviderRouterSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InterconnectAttachmentInitProviderRouterSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InterconnectAttachmentInitProviderRouterSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentInitProviderRouterSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentInitProviderRouterSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InterconnectAttachmentProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InterconnectAttachmentProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InterconnectAttachmentProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<InterconnectAttachmentPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<InterconnectAttachmentPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InterconnectAttachmentPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InterconnectAttachmentPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InterconnectAttachmentPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InterconnectAttachmentPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// InterconnectAttachmentStatus defines the observed state of InterconnectAttachment.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<InterconnectAttachmentStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentStatusAtProvider {
    /// Whether the VLAN attachment is enabled or disabled.  When using
    /// PARTNER type this will Pre-Activate the interconnect attachment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminEnabled")]
    #[builder(default)]
    pub admin_enabled: Option<bool>,
    /// Provisioned bandwidth capacity for the interconnect attachment.
    /// For attachments of type DEDICATED, the user can set the bandwidth.
    /// For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth.
    /// Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED,
    /// Defaults to BPS_10G
    /// Possible values are: BPS_50M, BPS_100M, BPS_200M, BPS_300M, BPS_400M, BPS_500M, BPS_1G, BPS_2G, BPS_5G, BPS_10G, BPS_20G, BPS_50G.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bandwidth: Option<String>,
    /// Up to 16 candidate prefixes that can be used to restrict the allocation
    /// of cloudRouterIpAddress and customerRouterIpAddress for this attachment.
    /// All prefixes must be within link-local address space (169.254.0.0/16)
    /// and must be /29 or shorter (/28, /27, etc). Google will attempt to select
    /// an unused /29 from the supplied candidate prefix(es). The request will
    /// fail if all possible /29s are in use on Google's edge. If not supplied,
    /// Google will randomly select an unused /29 from all of link-local space.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "candidateSubnets")]
    #[builder(default)]
    pub candidate_subnets: Option<Vec<String>>,
    /// IPv4 address + prefix length to be configured on Cloud Router
    /// Interface for this interconnect attachment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudRouterIpAddress")]
    #[builder(default)]
    pub cloud_router_ip_address: Option<String>,
    /// IPv6 address + prefix length to be configured on Cloud Router
    /// Interface for this interconnect attachment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudRouterIpv6Address")]
    #[builder(default)]
    pub cloud_router_ipv6_address: Option<String>,
    /// Creation timestamp in RFC3339 text format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationTimestamp")]
    #[builder(default)]
    pub creation_timestamp: Option<String>,
    /// IPv4 address + prefix length to be configured on the customer
    /// router subinterface for this interconnect attachment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customerRouterIpAddress")]
    #[builder(default)]
    pub customer_router_ip_address: Option<String>,
    /// IPv6 address + prefix length to be configured on the customer
    /// router subinterface for this interconnect attachment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customerRouterIpv6Address")]
    #[builder(default)]
    pub customer_router_ipv6_address: Option<String>,
    /// An optional description of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Desired availability domain for the attachment. Only available for type
    /// PARTNER, at creation time. For improved reliability, customers should
    /// configure a pair of attachments with one per availability domain. The
    /// selected availability domain will be provided to the Partner via the
    /// pairing key so that the provisioned circuit will lie in the specified
    /// domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "edgeAvailabilityDomain")]
    #[builder(default)]
    pub edge_availability_domain: Option<String>,
    /// Indicates the user-supplied encryption option of this interconnect
    /// attachment. Can only be specified at attachment creation for PARTNER or
    /// DEDICATED attachments.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encryption: Option<String>,
    /// Google reference ID, to be used when raising support tickets with
    /// Google or otherwise to debug backend connectivity issues.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "googleReferenceId")]
    #[builder(default)]
    pub google_reference_id: Option<String>,
    /// an identifier for the resource with format projects/{{project}}/regions/{{region}}/interconnectAttachments/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// URL of the underlying Interconnect object that this attachment's
    /// traffic will traverse through. Required if type is DEDICATED, must not
    /// be set if type is PARTNER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub interconnect: Option<String>,
    /// URL of addresses that have been reserved for the interconnect attachment,
    /// Used only for interconnect attachment that has the encryption option as
    /// IPSEC.
    /// The addresses must be RFC 1918 IP address ranges. When creating HA VPN
    /// gateway over the interconnect attachment, if the attachment is configured
    /// to use an RFC 1918 IP address, then the VPN gateway's IP address will be
    /// allocated from the IP address range specified here.
    /// For example, if the HA VPN gateway's interface 0 is paired to this
    /// interconnect attachment, then an RFC 1918 IP address for the VPN gateway
    /// interface 0 will be allocated from the IP address specified for this
    /// interconnect attachment.
    /// If this field is not specified for interconnect attachment that has
    /// encryption option as IPSEC, later on when creating HA VPN gateway on this
    /// interconnect attachment, the HA VPN gateway's IP address will be
    /// allocated from regional external IP address pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipsecInternalAddresses")]
    #[builder(default)]
    pub ipsec_internal_addresses: Option<Vec<String>>,
    /// Maximum Transmission Unit (MTU), in bytes, of packets passing through
    /// this interconnect attachment. Currently, only 1440 and 1500 are allowed. If not specified, the value will default to 1440.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mtu: Option<String>,
    /// [Output only for type PARTNER. Not present for DEDICATED]. The opaque
    /// identifier of an PARTNER attachment used to initiate provisioning with
    /// a selected partner. Of the form "XXXXX/region/domain"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pairingKey")]
    #[builder(default)]
    pub pairing_key: Option<String>,
    /// [Output only for type PARTNER. Not present for DEDICATED]. Optional
    /// BGP ASN for the router that should be supplied by a layer 3 Partner if
    /// they configured BGP on behalf of the customer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "partnerAsn")]
    #[builder(default)]
    pub partner_asn: Option<String>,
    /// Information specific to an InterconnectAttachment. This property
    /// is populated if the interconnect that this is attached to is of type DEDICATED.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateInterconnectInfo")]
    #[builder(default)]
    pub private_interconnect_info: Option<Vec<InterconnectAttachmentStatusAtProviderPrivateInterconnectInfo>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Region where the regional interconnect attachment resides.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    /// URL of the cloud router to be used for dynamic routing. This router must be in
    /// the same region as this InterconnectAttachment. The InterconnectAttachment will
    /// automatically connect the Interconnect to the network & region within which the
    /// Cloud Router is configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub router: Option<String>,
    /// The URI of the created resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLink")]
    #[builder(default)]
    pub self_link: Option<String>,
    /// The stack type for this interconnect attachment to identify whether the IPv6
    /// feature is enabled or not. If not specified, IPV4_ONLY will be used.
    /// This field can be both set at interconnect attachments creation and update
    /// interconnect attachment operations.
    /// Possible values are: IPV4_IPV6, IPV4_ONLY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    #[builder(default)]
    pub stack_type: Option<String>,
    /// [Output Only] The current state of this attachment's functionality.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub state: Option<String>,
    /// Length of the IPv4 subnet mask. Allowed values: 29 (default), 30. The default value is 29,
    /// except for Cross-Cloud Interconnect connections that use an InterconnectRemoteLocation with a
    /// constraints.subnetLengthRange.min equal to 30. For example, connections that use an Azure
    /// remote location fall into this category. In these cases, the default value is 30, and
    /// requesting 29 returns an error. Where both 29 and 30 are allowed, 29 is preferred, because it
    /// gives Google Cloud Support more debugging visibility.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetLength")]
    #[builder(default)]
    pub subnet_length: Option<f64>,
    /// The type of InterconnectAttachment you wish to create. Defaults to
    /// DEDICATED.
    /// Possible values are: DEDICATED, PARTNER, PARTNER_PROVIDER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
    /// The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. When
    /// using PARTNER type this will be managed upstream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vlanTag8021Q")]
    #[builder(default)]
    pub vlan_tag8021_q: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InterconnectAttachmentStatusAtProviderPrivateInterconnectInfo {
    /// (Output)
    /// 802.1q encapsulation tag to be used for traffic between
    /// Google and the customer, going to and from this network and region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag8021q: Option<f64>,
}

