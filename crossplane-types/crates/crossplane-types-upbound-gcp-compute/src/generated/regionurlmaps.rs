// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// RegionURLMapSpec defines the desired state of RegionURLMap
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta2", kind = "RegionURLMap", plural = "regionurlmaps")]
#[kube(status = "RegionURLMapStatus")]
pub struct RegionURLMapSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<RegionURLMapDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: RegionURLMapForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<RegionURLMapInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<RegionURLMapProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<RegionURLMapPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<RegionURLMapWriteConnectionSecretToRef>,
}

/// RegionURLMapSpec defines the desired state of RegionURLMap
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProvider {
    /// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
    /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
    /// URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
    /// defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRouteAction")]
    #[builder(default)]
    pub default_route_action: Option<RegionURLMapForProviderDefaultRouteAction>,
    /// The full or partial URL of the defaultService resource to which traffic is directed if
    /// none of the hostRules match. If defaultRouteAction is additionally specified, advanced
    /// routing actions like URL Rewrites, etc. take effect prior to sending the request to the
    /// backend. However, if defaultService is specified, defaultRouteAction cannot contain any
    /// weightedBackendServices. Conversely, if routeAction specifies any
    /// weightedBackendServices, service must not be specified.  Only one of defaultService,
    /// defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultService")]
    #[builder(default)]
    pub default_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceRef")]
    #[builder(default)]
    pub default_service_ref: Option<RegionURLMapForProviderDefaultServiceRef>,
    /// Selector for a RegionBackendService in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceSelector")]
    #[builder(default)]
    pub default_service_selector: Option<RegionURLMapForProviderDefaultServiceSelector>,
    /// When none of the specified hostRules match, the request is redirected to a URL specified
    /// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    /// defaultRouteAction must not be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUrlRedirect")]
    #[builder(default)]
    pub default_url_redirect: Option<RegionURLMapForProviderDefaultUrlRedirect>,
    /// An optional description of this resource. Provide this property when
    /// you create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The list of HostRules to use against the URL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRule")]
    #[builder(default)]
    pub host_rule: Option<Vec<RegionURLMapForProviderHostRule>>,
    /// The list of named PathMatchers to use against the URL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathMatcher")]
    #[builder(default)]
    pub path_matcher: Option<Vec<RegionURLMapForProviderPathMatcher>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The Region in which the url map should reside.
    /// If it is not provided, the provider region is used.
    pub region: String,
    /// The list of expected URL mappings. Requests to update this UrlMap will
    /// succeed only if all of the test cases pass.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub test: Option<Vec<RegionURLMapForProviderTest>>,
}

/// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
/// Only one of defaultRouteAction or defaultUrlRedirect must be set.
/// URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
/// defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see
    /// W3C Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<RegionURLMapForProviderDefaultRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
    /// As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
    /// Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
    /// timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
    /// Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: Routing and traffic management features.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<RegionURLMapForProviderDefaultRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
    /// The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
    /// Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<RegionURLMapForProviderDefaultRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
    /// If not specified, this field uses the largest timeout among all backend services associated with the route.
    /// Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<RegionURLMapForProviderDefaultRouteActionTimeout>,
    /// The spec to modify the URL of the request, before forwarding the request to the matched service.
    /// urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
    /// Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<RegionURLMapForProviderDefaultRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match occurs. The weights determine the fraction of traffic that flows to their corresponding backend service. If all traffic needs to go to a single backend service, there must be one weightedBackendService with weight set to a non-zero number.
    /// After a backend service is identified and before forwarding the request to the backend service, advanced routing actions such as URL rewrites and header transformations are applied depending on additional settings specified in this HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<RegionURLMapForProviderDefaultRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see
/// W3C Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    /// which indicates that the CORS policy is in effect. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
/// As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
/// Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
/// timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
/// Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: Routing and traffic management features.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<RegionURLMapForProviderDefaultRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<RegionURLMapForProviderDefaultRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<RegionURLMapForProviderDefaultRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
/// The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
/// Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicy {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRef>,
    /// Selector for a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelector>,
}

/// Reference to a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<RegionURLMapForProviderDefaultRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
/// If not specified, this field uses the largest timeout among all backend services associated with the route.
/// Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, before forwarding the request to the matched service.
/// urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
/// Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionWeightedBackendServices {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceRef>,
    /// Selector for a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelector>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Reference to a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a RegionBackendService in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderDefaultServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderDefaultServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderDefaultServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderDefaultServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderDefaultServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderDefaultServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderDefaultServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderDefaultServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderDefaultServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderDefaultServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When none of the specified hostRules match, the request is redirected to a URL specified
/// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
/// defaultRouteAction must not be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderDefaultUrlRedirect {
    /// The host that will be used in the redirect response instead of the one that was
    /// supplied in the request. The value must be between 1 and 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https. If set to
    /// false, the URL scheme of the redirected request will remain the same as that of the
    /// request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    /// true for TargetHttpsProxy is not permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one that was
    /// supplied in the request. pathRedirect cannot be supplied together with
    /// prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    /// original request will be used for the redirect. The value must be between 1 and 1024
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    /// retaining the remaining portion of the URL before redirecting the request.
    /// prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    /// neither. If neither is supplied, the path of the original request will be used for
    /// the redirect. The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is removed prior
    /// to redirecting the request. If set to false, the query portion of the original URL is
    /// retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderHostRule {
    /// An optional description of this HostRule. Provide this property
    /// when you create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The list of host patterns to match. They must be valid
    /// hostnames, except * will match any string of ([a-z0-9-.]*). In
    /// that case, * must be the first character and must be followed in
    /// the pattern by either - or ..
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hosts: Option<Vec<String>>,
    /// The name of the PathMatcher to use to match the path portion of
    /// the URL if the hostRule matches the URL's host portion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathMatcher")]
    #[builder(default)]
    pub path_matcher: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcher {
    /// A reference to a RegionBackendService resource. This will be used if
    /// none of the pathRules defined by this PathMatcher is matched by
    /// the URL's path portion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultService")]
    #[builder(default)]
    pub default_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceRef")]
    #[builder(default)]
    pub default_service_ref: Option<RegionURLMapForProviderPathMatcherDefaultServiceRef>,
    /// Selector for a RegionBackendService in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceSelector")]
    #[builder(default)]
    pub default_service_selector: Option<RegionURLMapForProviderPathMatcherDefaultServiceSelector>,
    /// When none of the specified hostRules match, the request is redirected to a URL specified
    /// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    /// defaultRouteAction must not be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUrlRedirect")]
    #[builder(default)]
    pub default_url_redirect: Option<RegionURLMapForProviderPathMatcherDefaultUrlRedirect>,
    /// An optional description of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The name to which this PathMatcher is referred by the HostRule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The list of path rules. Use this list instead of routeRules when routing based
    /// on simple path matching is all that's required. The order by which path rules
    /// are specified does not matter. Matches are always done on the longest-path-first
    /// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
    /// irrespective of the order in which those paths appear in this list. Within a
    /// given pathMatcher, only one of pathRules or routeRules must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRule")]
    #[builder(default)]
    pub path_rule: Option<Vec<RegionURLMapForProviderPathMatcherPathRule>>,
    /// The list of ordered HTTP route rules. Use this list instead of pathRules when
    /// advanced route matching and routing actions are desired. The order of specifying
    /// routeRules matters: the first rule that matches will cause its specified routing
    /// action to take effect. Within a given pathMatcher, only one of pathRules or
    /// routeRules must be set. routeRules are not supported in UrlMaps intended for
    /// External load balancers.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeRules")]
    #[builder(default)]
    pub route_rules: Option<Vec<RegionURLMapForProviderPathMatcherRouteRules>>,
}

/// Reference to a RegionBackendService in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherDefaultServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderPathMatcherDefaultServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherDefaultServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderPathMatcherDefaultServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderPathMatcherDefaultServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherDefaultServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherDefaultServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherDefaultServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderPathMatcherDefaultServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherDefaultServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderPathMatcherDefaultServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderPathMatcherDefaultServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherDefaultServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherDefaultServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When none of the specified hostRules match, the request is redirected to a URL specified
/// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
/// defaultRouteAction must not be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherDefaultUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained. The default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRule {
    /// The list of path patterns to match. Each must start with / and the only place a
    /// * is allowed is at the end following a /. The string fed to the path matcher
    /// does not include any text after the first ? or #, and those chars are not
    /// allowed here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paths: Option<Vec<String>>,
    /// In response to a matching matchRule, the load balancer performs advanced routing
    /// actions like URL rewrites, header transformations, etc. prior to forwarding the
    /// request to the selected backend. If  routeAction specifies any
    /// weightedBackendServices, service must not be set. Conversely if service is set,
    /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    /// or urlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAction")]
    #[builder(default)]
    pub route_action: Option<RegionURLMapForProviderPathMatcherPathRuleRouteAction>,
    /// A reference to expected RegionBackendService resource the given URL should be mapped to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<RegionURLMapForProviderPathMatcherPathRuleServiceRef>,
    /// Selector for a RegionBackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<RegionURLMapForProviderPathMatcherPathRuleServiceSelector>,
    /// When this rule is matched, the request is redirected to a URL specified by
    /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
    /// set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRedirect")]
    #[builder(default)]
    pub url_redirect: Option<RegionURLMapForProviderPathMatcherPathRuleUrlRedirect>,
}

/// In response to a matching matchRule, the load balancer performs advanced routing
/// actions like URL rewrites, header transformations, etc. prior to forwarding the
/// request to the selected backend. If  routeAction specifies any
/// weightedBackendServices, service must not be set. Conversely if service is set,
/// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
/// or urlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    /// which indicates that the CORS policy is in effect. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicy {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef>,
    /// Selector for a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelector>,
}

/// Reference to a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServices {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef>,
    /// Selector for a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelector>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Reference to a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a RegionBackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderPathMatcherPathRuleServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderPathMatcherPathRuleServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderPathMatcherPathRuleServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherPathRuleServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherPathRuleServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderPathMatcherPathRuleServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderPathMatcherPathRuleServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderPathMatcherPathRuleServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherPathRuleServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherPathRuleServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When this rule is matched, the request is redirected to a URL specified by
/// urlRedirect. If urlRedirect is specified, service or routeAction must not be
/// set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherPathRuleUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained. The default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRules {
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<RegionURLMapForProviderPathMatcherRouteRulesHeaderAction>,
    /// The rules for determining a match.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchRules")]
    #[builder(default)]
    pub match_rules: Option<Vec<RegionURLMapForProviderPathMatcherRouteRulesMatchRules>>,
    /// For routeRules within a given pathMatcher, priority determines the order
    /// in which load balancer will interpret routeRules. RouteRules are evaluated
    /// in order of priority, from the lowest to highest number. The priority of
    /// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
    /// that matches the request is applied.
    /// You cannot configure two or more routeRules with the same priority.
    /// Priority for each rule must be set to a number between 0 and
    /// 2147483647 inclusive.
    /// Priority numbers can have gaps, which enable you to add or remove rules
    /// in the future without affecting the rest of the rules. For example,
    /// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
    /// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
    /// future without any impact on existing rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub priority: Option<f64>,
    /// In response to a matching matchRule, the load balancer performs advanced routing
    /// actions like URL rewrites, header transformations, etc. prior to forwarding the
    /// request to the selected backend. If  routeAction specifies any
    /// weightedBackendServices, service must not be set. Conversely if service is set,
    /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    /// or urlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAction")]
    #[builder(default)]
    pub route_action: Option<RegionURLMapForProviderPathMatcherRouteRulesRouteAction>,
    /// A reference to expected RegionBackendService resource the given URL should be mapped to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<RegionURLMapForProviderPathMatcherRouteRulesServiceRef>,
    /// Selector for a RegionBackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<RegionURLMapForProviderPathMatcherRouteRulesServiceSelector>,
    /// When this rule is matched, the request is redirected to a URL specified by
    /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
    /// set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRedirect")]
    #[builder(default)]
    pub url_redirect: Option<RegionURLMapForProviderPathMatcherRouteRulesUrlRedirect>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<RegionURLMapForProviderPathMatcherRouteRulesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<RegionURLMapForProviderPathMatcherRouteRulesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesMatchRules {
    /// For satisfying the matchRule condition, the path of the request must exactly
    /// match the value specified in fullPathMatch after removing any query parameters
    /// and anchor that may be part of the original URL. FullPathMatch must be between 1
    /// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
    /// be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fullPathMatch")]
    #[builder(default)]
    pub full_path_match: Option<String>,
    /// Specifies a list of header match criteria, all of which must match corresponding
    /// headers in the request.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    #[builder(default)]
    pub header_matches: Option<Vec<RegionURLMapForProviderPathMatcherRouteRulesMatchRulesHeaderMatches>>,
    /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    #[builder(default)]
    pub ignore_case: Option<bool>,
    /// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
    /// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
    /// clients present node metadata. If a match takes place, the relevant routing
    /// configuration is made available to those proxies. For each metadataFilter in
    /// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
    /// filterLabels must match the corresponding label provided in the metadata. If its
    /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
    /// with corresponding labels in the provided metadata. metadataFilters specified
    /// here can be overrides those specified in ForwardingRule that refers to this
    /// UrlMap. metadataFilters only applies to Loadbalancers that have their
    /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataFilters")]
    #[builder(default)]
    pub metadata_filters: Option<Vec<RegionURLMapForProviderPathMatcherRouteRulesMatchRulesMetadataFilters>>,
    /// For satisfying the matchRule condition, the path of the request
    /// must match the wildcard pattern specified in pathTemplateMatch
    /// after removing any query parameters and anchor that may be part
    /// of the original URL.
    /// pathTemplateMatch must be between 1 and 255 characters
    /// (inclusive).  The pattern specified by pathTemplateMatch may
    /// have at most 5 wildcard operators and at most 5 variable
    /// captures in total.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTemplateMatch")]
    #[builder(default)]
    pub path_template_match: Option<String>,
    /// For satisfying the matchRule condition, the request's path must begin with the
    /// specified prefixMatch. prefixMatch must begin with a /. The value must be
    /// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
    /// regexMatch must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixMatch")]
    #[builder(default)]
    pub prefix_match: Option<String>,
    /// Specifies a list of query parameter match criteria, all of which must match
    /// corresponding query parameters in the request.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParameterMatches")]
    #[builder(default)]
    pub query_parameter_matches: Option<Vec<RegionURLMapForProviderPathMatcherRouteRulesMatchRulesQueryParameterMatches>>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesMatchRulesHeaderMatches {
    /// The queryParameterMatch matches if the value of the parameter exactly matches
    /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exactMatch")]
    #[builder(default)]
    pub exact_match: Option<String>,
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// If set to false, the headerMatch is considered a match if the match criteria
    /// above are met. If set to true, the headerMatch is considered a match if the
    /// match criteria above are NOT met. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertMatch")]
    #[builder(default)]
    pub invert_match: Option<bool>,
    /// For satisfying the matchRule condition, the request's path must begin with the
    /// specified prefixMatch. prefixMatch must begin with a /. The value must be
    /// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
    /// regexMatch must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixMatch")]
    #[builder(default)]
    pub prefix_match: Option<String>,
    /// Specifies that the queryParameterMatch matches if the request contains the query
    /// parameter, irrespective of whether the parameter has a value or not. Only one of
    /// presentMatch, exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "presentMatch")]
    #[builder(default)]
    pub present_match: Option<bool>,
    /// The header value must be an integer and its value must be in the range specified
    /// in rangeMatch. If the header does not contain an integer, number or is empty,
    /// the match fails. For example for a range [-5, 0]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeMatch")]
    #[builder(default)]
    pub range_match: Option<RegionURLMapForProviderPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
    /// The value of the header must end with the contents of suffixMatch. Only one of
    /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "suffixMatch")]
    #[builder(default)]
    pub suffix_match: Option<String>,
}

/// The header value must be an integer and its value must be in the range specified
/// in rangeMatch. If the header does not contain an integer, number or is empty,
/// the match fails. For example for a range [-5, 0]
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch {
    /// The end of the range (exclusive).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeEnd")]
    #[builder(default)]
    pub range_end: Option<f64>,
    /// The start of the range (inclusive).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeStart")]
    #[builder(default)]
    pub range_start: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesMatchRulesMetadataFilters {
    /// The list of label value pairs that must match labels in the provided metadata
    /// based on filterMatchCriteria  This list must not be empty and can have at the
    /// most 64 entries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterLabels")]
    #[builder(default)]
    pub filter_labels: Option<Vec<RegionURLMapForProviderPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels>>,
    /// Specifies how individual filterLabel matches within the list of filterLabels
    /// contribute towards the overall metadataFilter match. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterMatchCriteria")]
    #[builder(default)]
    pub filter_match_criteria: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels {
    /// The name of the query parameter to match. The query parameter must exist in the
    /// request, in the absence of which the request match fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The value of the label must match the specified value. value can have a maximum
    /// length of 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesMatchRulesQueryParameterMatches {
    /// The queryParameterMatch matches if the value of the parameter exactly matches
    /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exactMatch")]
    #[builder(default)]
    pub exact_match: Option<String>,
    /// The name of the query parameter to match. The query parameter must exist in the
    /// request, in the absence of which the request match fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Specifies that the queryParameterMatch matches if the request contains the query
    /// parameter, irrespective of whether the parameter has a value or not. Only one of
    /// presentMatch, exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "presentMatch")]
    #[builder(default)]
    pub present_match: Option<bool>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
}

/// In response to a matching matchRule, the load balancer performs advanced routing
/// actions like URL rewrites, header transformations, etc. prior to forwarding the
/// request to the selected backend. If  routeAction specifies any
/// weightedBackendServices, service must not be set. Conversely if service is set,
/// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
/// or urlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<RegionURLMapForProviderPathMatcherRouteRulesRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<RegionURLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<RegionURLMapForProviderPathMatcherRouteRulesRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<RegionURLMapForProviderPathMatcherRouteRulesRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<RegionURLMapForProviderPathMatcherRouteRulesRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<RegionURLMapForProviderPathMatcherRouteRulesRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<RegionURLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    /// which indicates that the CORS policy is in effect. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<RegionURLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<RegionURLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<RegionURLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionRequestMirrorPolicy {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<RegionURLMapForProviderPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected origin, if the
    /// request matched a pathTemplateMatch, the matching portion of the
    /// request's path is replaced re-written using the pattern specified
    /// by pathTemplateRewrite.
    /// pathTemplateRewrite must be between 1 and 255 characters
    /// (inclusive), must start with a '/', and must only use variables
    /// captured by the route's pathTemplate matchers.
    /// pathTemplateRewrite may only be used when all of a route's
    /// MatchRules specify pathTemplate.
    /// Only one of pathPrefixRewrite and pathTemplateRewrite may be
    /// specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTemplateRewrite")]
    #[builder(default)]
    pub path_template_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServices {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<RegionURLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<RegionURLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<RegionURLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a RegionBackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderPathMatcherRouteRulesServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderPathMatcherRouteRulesServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderPathMatcherRouteRulesServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherRouteRulesServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherRouteRulesServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderPathMatcherRouteRulesServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderPathMatcherRouteRulesServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderPathMatcherRouteRulesServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherRouteRulesServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderPathMatcherRouteRulesServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When this rule is matched, the request is redirected to a URL specified by
/// urlRedirect. If urlRedirect is specified, service or routeAction must not be
/// set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderPathMatcherRouteRulesUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained. The default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderTest {
    /// Description of this test case.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Host portion of the URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub host: Option<String>,
    /// Path portion of the URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// A reference to expected RegionBackendService resource the given URL should be mapped to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<RegionURLMapForProviderTestServiceRef>,
    /// Selector for a RegionBackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<RegionURLMapForProviderTestServiceSelector>,
}

/// Reference to a RegionBackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderTestServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderTestServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderTestServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderTestServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderTestServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderTestServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderTestServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderTestServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapForProviderTestServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapForProviderTestServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapForProviderTestServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapForProviderTestServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderTestServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapForProviderTestServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProvider {
    /// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
    /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
    /// URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
    /// defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRouteAction")]
    #[builder(default)]
    pub default_route_action: Option<RegionURLMapInitProviderDefaultRouteAction>,
    /// The full or partial URL of the defaultService resource to which traffic is directed if
    /// none of the hostRules match. If defaultRouteAction is additionally specified, advanced
    /// routing actions like URL Rewrites, etc. take effect prior to sending the request to the
    /// backend. However, if defaultService is specified, defaultRouteAction cannot contain any
    /// weightedBackendServices. Conversely, if routeAction specifies any
    /// weightedBackendServices, service must not be specified.  Only one of defaultService,
    /// defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultService")]
    #[builder(default)]
    pub default_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceRef")]
    #[builder(default)]
    pub default_service_ref: Option<RegionURLMapInitProviderDefaultServiceRef>,
    /// Selector for a RegionBackendService in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceSelector")]
    #[builder(default)]
    pub default_service_selector: Option<RegionURLMapInitProviderDefaultServiceSelector>,
    /// When none of the specified hostRules match, the request is redirected to a URL specified
    /// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    /// defaultRouteAction must not be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUrlRedirect")]
    #[builder(default)]
    pub default_url_redirect: Option<RegionURLMapInitProviderDefaultUrlRedirect>,
    /// An optional description of this resource. Provide this property when
    /// you create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The list of HostRules to use against the URL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRule")]
    #[builder(default)]
    pub host_rule: Option<Vec<RegionURLMapInitProviderHostRule>>,
    /// The list of named PathMatchers to use against the URL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathMatcher")]
    #[builder(default)]
    pub path_matcher: Option<Vec<RegionURLMapInitProviderPathMatcher>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The list of expected URL mappings. Requests to update this UrlMap will
    /// succeed only if all of the test cases pass.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub test: Option<Vec<RegionURLMapInitProviderTest>>,
}

/// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
/// Only one of defaultRouteAction or defaultUrlRedirect must be set.
/// URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
/// defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see
    /// W3C Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<RegionURLMapInitProviderDefaultRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
    /// As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
    /// Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
    /// timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
    /// Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: Routing and traffic management features.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<RegionURLMapInitProviderDefaultRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
    /// The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
    /// Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<RegionURLMapInitProviderDefaultRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
    /// If not specified, this field uses the largest timeout among all backend services associated with the route.
    /// Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<RegionURLMapInitProviderDefaultRouteActionTimeout>,
    /// The spec to modify the URL of the request, before forwarding the request to the matched service.
    /// urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
    /// Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<RegionURLMapInitProviderDefaultRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match occurs. The weights determine the fraction of traffic that flows to their corresponding backend service. If all traffic needs to go to a single backend service, there must be one weightedBackendService with weight set to a non-zero number.
    /// After a backend service is identified and before forwarding the request to the backend service, advanced routing actions such as URL rewrites and header transformations are applied depending on additional settings specified in this HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<RegionURLMapInitProviderDefaultRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see
/// W3C Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    /// which indicates that the CORS policy is in effect. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
/// As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
/// Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
/// timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
/// Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: Routing and traffic management features.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<RegionURLMapInitProviderDefaultRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<RegionURLMapInitProviderDefaultRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<RegionURLMapInitProviderDefaultRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
/// The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
/// Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicy {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRef>,
    /// Selector for a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelector>,
}

/// Reference to a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderDefaultRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<RegionURLMapInitProviderDefaultRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
/// If not specified, this field uses the largest timeout among all backend services associated with the route.
/// Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, before forwarding the request to the matched service.
/// urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
/// Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionWeightedBackendServices {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceRef>,
    /// Selector for a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelector>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Reference to a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a RegionBackendService in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderDefaultServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderDefaultServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderDefaultServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderDefaultServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderDefaultServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderDefaultServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderDefaultServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderDefaultServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderDefaultServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderDefaultServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When none of the specified hostRules match, the request is redirected to a URL specified
/// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
/// defaultRouteAction must not be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderDefaultUrlRedirect {
    /// The host that will be used in the redirect response instead of the one that was
    /// supplied in the request. The value must be between 1 and 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https. If set to
    /// false, the URL scheme of the redirected request will remain the same as that of the
    /// request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    /// true for TargetHttpsProxy is not permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one that was
    /// supplied in the request. pathRedirect cannot be supplied together with
    /// prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    /// original request will be used for the redirect. The value must be between 1 and 1024
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    /// retaining the remaining portion of the URL before redirecting the request.
    /// prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    /// neither. If neither is supplied, the path of the original request will be used for
    /// the redirect. The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is removed prior
    /// to redirecting the request. If set to false, the query portion of the original URL is
    /// retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderHostRule {
    /// An optional description of this HostRule. Provide this property
    /// when you create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The list of host patterns to match. They must be valid
    /// hostnames, except * will match any string of ([a-z0-9-.]*). In
    /// that case, * must be the first character and must be followed in
    /// the pattern by either - or ..
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hosts: Option<Vec<String>>,
    /// The name of the PathMatcher to use to match the path portion of
    /// the URL if the hostRule matches the URL's host portion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathMatcher")]
    #[builder(default)]
    pub path_matcher: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcher {
    /// A reference to a RegionBackendService resource. This will be used if
    /// none of the pathRules defined by this PathMatcher is matched by
    /// the URL's path portion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultService")]
    #[builder(default)]
    pub default_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceRef")]
    #[builder(default)]
    pub default_service_ref: Option<RegionURLMapInitProviderPathMatcherDefaultServiceRef>,
    /// Selector for a RegionBackendService in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceSelector")]
    #[builder(default)]
    pub default_service_selector: Option<RegionURLMapInitProviderPathMatcherDefaultServiceSelector>,
    /// When none of the specified hostRules match, the request is redirected to a URL specified
    /// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    /// defaultRouteAction must not be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUrlRedirect")]
    #[builder(default)]
    pub default_url_redirect: Option<RegionURLMapInitProviderPathMatcherDefaultUrlRedirect>,
    /// An optional description of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The name to which this PathMatcher is referred by the HostRule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The list of path rules. Use this list instead of routeRules when routing based
    /// on simple path matching is all that's required. The order by which path rules
    /// are specified does not matter. Matches are always done on the longest-path-first
    /// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
    /// irrespective of the order in which those paths appear in this list. Within a
    /// given pathMatcher, only one of pathRules or routeRules must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRule")]
    #[builder(default)]
    pub path_rule: Option<Vec<RegionURLMapInitProviderPathMatcherPathRule>>,
    /// The list of ordered HTTP route rules. Use this list instead of pathRules when
    /// advanced route matching and routing actions are desired. The order of specifying
    /// routeRules matters: the first rule that matches will cause its specified routing
    /// action to take effect. Within a given pathMatcher, only one of pathRules or
    /// routeRules must be set. routeRules are not supported in UrlMaps intended for
    /// External load balancers.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeRules")]
    #[builder(default)]
    pub route_rules: Option<Vec<RegionURLMapInitProviderPathMatcherRouteRules>>,
}

/// Reference to a RegionBackendService in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherDefaultServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderPathMatcherDefaultServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherDefaultServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderPathMatcherDefaultServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderPathMatcherDefaultServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherDefaultServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherDefaultServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherDefaultServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderPathMatcherDefaultServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherDefaultServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderPathMatcherDefaultServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderPathMatcherDefaultServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherDefaultServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherDefaultServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When none of the specified hostRules match, the request is redirected to a URL specified
/// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
/// defaultRouteAction must not be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherDefaultUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained. The default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRule {
    /// The list of path patterns to match. Each must start with / and the only place a
    /// * is allowed is at the end following a /. The string fed to the path matcher
    /// does not include any text after the first ? or #, and those chars are not
    /// allowed here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paths: Option<Vec<String>>,
    /// In response to a matching matchRule, the load balancer performs advanced routing
    /// actions like URL rewrites, header transformations, etc. prior to forwarding the
    /// request to the selected backend. If  routeAction specifies any
    /// weightedBackendServices, service must not be set. Conversely if service is set,
    /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    /// or urlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAction")]
    #[builder(default)]
    pub route_action: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteAction>,
    /// A reference to expected RegionBackendService resource the given URL should be mapped to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<RegionURLMapInitProviderPathMatcherPathRuleServiceRef>,
    /// Selector for a RegionBackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<RegionURLMapInitProviderPathMatcherPathRuleServiceSelector>,
    /// When this rule is matched, the request is redirected to a URL specified by
    /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
    /// set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRedirect")]
    #[builder(default)]
    pub url_redirect: Option<RegionURLMapInitProviderPathMatcherPathRuleUrlRedirect>,
}

/// In response to a matching matchRule, the load balancer performs advanced routing
/// actions like URL rewrites, header transformations, etc. prior to forwarding the
/// request to the selected backend. If  routeAction specifies any
/// weightedBackendServices, service must not be set. Conversely if service is set,
/// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
/// or urlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    /// which indicates that the CORS policy is in effect. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicy {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef>,
    /// Selector for a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelector>,
}

/// Reference to a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServices {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef>,
    /// Selector for a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelector>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Reference to a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a RegionBackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderPathMatcherPathRuleServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderPathMatcherPathRuleServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderPathMatcherPathRuleServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherPathRuleServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherPathRuleServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderPathMatcherPathRuleServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderPathMatcherPathRuleServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderPathMatcherPathRuleServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherPathRuleServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherPathRuleServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When this rule is matched, the request is redirected to a URL specified by
/// urlRedirect. If urlRedirect is specified, service or routeAction must not be
/// set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherPathRuleUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained. The default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRules {
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<RegionURLMapInitProviderPathMatcherRouteRulesHeaderAction>,
    /// The rules for determining a match.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchRules")]
    #[builder(default)]
    pub match_rules: Option<Vec<RegionURLMapInitProviderPathMatcherRouteRulesMatchRules>>,
    /// For routeRules within a given pathMatcher, priority determines the order
    /// in which load balancer will interpret routeRules. RouteRules are evaluated
    /// in order of priority, from the lowest to highest number. The priority of
    /// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
    /// that matches the request is applied.
    /// You cannot configure two or more routeRules with the same priority.
    /// Priority for each rule must be set to a number between 0 and
    /// 2147483647 inclusive.
    /// Priority numbers can have gaps, which enable you to add or remove rules
    /// in the future without affecting the rest of the rules. For example,
    /// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
    /// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
    /// future without any impact on existing rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub priority: Option<f64>,
    /// In response to a matching matchRule, the load balancer performs advanced routing
    /// actions like URL rewrites, header transformations, etc. prior to forwarding the
    /// request to the selected backend. If  routeAction specifies any
    /// weightedBackendServices, service must not be set. Conversely if service is set,
    /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    /// or urlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAction")]
    #[builder(default)]
    pub route_action: Option<RegionURLMapInitProviderPathMatcherRouteRulesRouteAction>,
    /// A reference to expected RegionBackendService resource the given URL should be mapped to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<RegionURLMapInitProviderPathMatcherRouteRulesServiceRef>,
    /// Selector for a RegionBackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<RegionURLMapInitProviderPathMatcherRouteRulesServiceSelector>,
    /// When this rule is matched, the request is redirected to a URL specified by
    /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
    /// set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRedirect")]
    #[builder(default)]
    pub url_redirect: Option<RegionURLMapInitProviderPathMatcherRouteRulesUrlRedirect>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<RegionURLMapInitProviderPathMatcherRouteRulesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<RegionURLMapInitProviderPathMatcherRouteRulesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesMatchRules {
    /// For satisfying the matchRule condition, the path of the request must exactly
    /// match the value specified in fullPathMatch after removing any query parameters
    /// and anchor that may be part of the original URL. FullPathMatch must be between 1
    /// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
    /// be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fullPathMatch")]
    #[builder(default)]
    pub full_path_match: Option<String>,
    /// Specifies a list of header match criteria, all of which must match corresponding
    /// headers in the request.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    #[builder(default)]
    pub header_matches: Option<Vec<RegionURLMapInitProviderPathMatcherRouteRulesMatchRulesHeaderMatches>>,
    /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    #[builder(default)]
    pub ignore_case: Option<bool>,
    /// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
    /// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
    /// clients present node metadata. If a match takes place, the relevant routing
    /// configuration is made available to those proxies. For each metadataFilter in
    /// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
    /// filterLabels must match the corresponding label provided in the metadata. If its
    /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
    /// with corresponding labels in the provided metadata. metadataFilters specified
    /// here can be overrides those specified in ForwardingRule that refers to this
    /// UrlMap. metadataFilters only applies to Loadbalancers that have their
    /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataFilters")]
    #[builder(default)]
    pub metadata_filters: Option<Vec<RegionURLMapInitProviderPathMatcherRouteRulesMatchRulesMetadataFilters>>,
    /// For satisfying the matchRule condition, the path of the request
    /// must match the wildcard pattern specified in pathTemplateMatch
    /// after removing any query parameters and anchor that may be part
    /// of the original URL.
    /// pathTemplateMatch must be between 1 and 255 characters
    /// (inclusive).  The pattern specified by pathTemplateMatch may
    /// have at most 5 wildcard operators and at most 5 variable
    /// captures in total.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTemplateMatch")]
    #[builder(default)]
    pub path_template_match: Option<String>,
    /// For satisfying the matchRule condition, the request's path must begin with the
    /// specified prefixMatch. prefixMatch must begin with a /. The value must be
    /// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
    /// regexMatch must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixMatch")]
    #[builder(default)]
    pub prefix_match: Option<String>,
    /// Specifies a list of query parameter match criteria, all of which must match
    /// corresponding query parameters in the request.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParameterMatches")]
    #[builder(default)]
    pub query_parameter_matches: Option<Vec<RegionURLMapInitProviderPathMatcherRouteRulesMatchRulesQueryParameterMatches>>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesMatchRulesHeaderMatches {
    /// The queryParameterMatch matches if the value of the parameter exactly matches
    /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exactMatch")]
    #[builder(default)]
    pub exact_match: Option<String>,
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// If set to false, the headerMatch is considered a match if the match criteria
    /// above are met. If set to true, the headerMatch is considered a match if the
    /// match criteria above are NOT met. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertMatch")]
    #[builder(default)]
    pub invert_match: Option<bool>,
    /// For satisfying the matchRule condition, the request's path must begin with the
    /// specified prefixMatch. prefixMatch must begin with a /. The value must be
    /// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
    /// regexMatch must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixMatch")]
    #[builder(default)]
    pub prefix_match: Option<String>,
    /// Specifies that the queryParameterMatch matches if the request contains the query
    /// parameter, irrespective of whether the parameter has a value or not. Only one of
    /// presentMatch, exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "presentMatch")]
    #[builder(default)]
    pub present_match: Option<bool>,
    /// The header value must be an integer and its value must be in the range specified
    /// in rangeMatch. If the header does not contain an integer, number or is empty,
    /// the match fails. For example for a range [-5, 0]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeMatch")]
    #[builder(default)]
    pub range_match: Option<RegionURLMapInitProviderPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
    /// The value of the header must end with the contents of suffixMatch. Only one of
    /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "suffixMatch")]
    #[builder(default)]
    pub suffix_match: Option<String>,
}

/// The header value must be an integer and its value must be in the range specified
/// in rangeMatch. If the header does not contain an integer, number or is empty,
/// the match fails. For example for a range [-5, 0]
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch {
    /// The end of the range (exclusive).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeEnd")]
    #[builder(default)]
    pub range_end: Option<f64>,
    /// The start of the range (inclusive).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeStart")]
    #[builder(default)]
    pub range_start: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesMatchRulesMetadataFilters {
    /// The list of label value pairs that must match labels in the provided metadata
    /// based on filterMatchCriteria  This list must not be empty and can have at the
    /// most 64 entries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterLabels")]
    #[builder(default)]
    pub filter_labels: Option<Vec<RegionURLMapInitProviderPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels>>,
    /// Specifies how individual filterLabel matches within the list of filterLabels
    /// contribute towards the overall metadataFilter match. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterMatchCriteria")]
    #[builder(default)]
    pub filter_match_criteria: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels {
    /// The name of the query parameter to match. The query parameter must exist in the
    /// request, in the absence of which the request match fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The value of the label must match the specified value. value can have a maximum
    /// length of 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesMatchRulesQueryParameterMatches {
    /// The queryParameterMatch matches if the value of the parameter exactly matches
    /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exactMatch")]
    #[builder(default)]
    pub exact_match: Option<String>,
    /// The name of the query parameter to match. The query parameter must exist in the
    /// request, in the absence of which the request match fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Specifies that the queryParameterMatch matches if the request contains the query
    /// parameter, irrespective of whether the parameter has a value or not. Only one of
    /// presentMatch, exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "presentMatch")]
    #[builder(default)]
    pub present_match: Option<bool>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
}

/// In response to a matching matchRule, the load balancer performs advanced routing
/// actions like URL rewrites, header transformations, etc. prior to forwarding the
/// request to the selected backend. If  routeAction specifies any
/// weightedBackendServices, service must not be set. Conversely if service is set,
/// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
/// or urlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    /// which indicates that the CORS policy is in effect. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionRequestMirrorPolicy {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected origin, if the
    /// request matched a pathTemplateMatch, the matching portion of the
    /// request's path is replaced re-written using the pattern specified
    /// by pathTemplateRewrite.
    /// pathTemplateRewrite must be between 1 and 255 characters
    /// (inclusive), must start with a '/', and must only use variables
    /// captured by the route's pathTemplate matchers.
    /// pathTemplateRewrite may only be used when all of a route's
    /// MatchRules specify pathTemplate.
    /// Only one of pathPrefixRewrite and pathTemplateRewrite may be
    /// specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTemplateRewrite")]
    #[builder(default)]
    pub path_template_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServices {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<RegionURLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a RegionBackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderPathMatcherRouteRulesServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderPathMatcherRouteRulesServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderPathMatcherRouteRulesServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherRouteRulesServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherRouteRulesServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderPathMatcherRouteRulesServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderPathMatcherRouteRulesServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderPathMatcherRouteRulesServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherRouteRulesServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderPathMatcherRouteRulesServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When this rule is matched, the request is redirected to a URL specified by
/// urlRedirect. If urlRedirect is specified, service or routeAction must not be
/// set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderPathMatcherRouteRulesUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained. The default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderTest {
    /// Description of this test case.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Host portion of the URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub host: Option<String>,
    /// Path portion of the URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// A reference to expected RegionBackendService resource the given URL should be mapped to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<RegionURLMapInitProviderTestServiceRef>,
    /// Selector for a RegionBackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<RegionURLMapInitProviderTestServiceSelector>,
}

/// Reference to a RegionBackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderTestServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderTestServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderTestServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderTestServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderTestServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderTestServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderTestServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderTestServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapInitProviderTestServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapInitProviderTestServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapInitProviderTestServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapInitProviderTestServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderTestServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapInitProviderTestServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<RegionURLMapPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<RegionURLMapPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RegionURLMapPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RegionURLMapPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RegionURLMapPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionURLMapPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// RegionURLMapStatus defines the observed state of RegionURLMap.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<RegionURLMapStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProvider {
    /// Creation timestamp in RFC3339 text format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationTimestamp")]
    #[builder(default)]
    pub creation_timestamp: Option<String>,
    /// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
    /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
    /// URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
    /// defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRouteAction")]
    #[builder(default)]
    pub default_route_action: Option<RegionURLMapStatusAtProviderDefaultRouteAction>,
    /// The full or partial URL of the defaultService resource to which traffic is directed if
    /// none of the hostRules match. If defaultRouteAction is additionally specified, advanced
    /// routing actions like URL Rewrites, etc. take effect prior to sending the request to the
    /// backend. However, if defaultService is specified, defaultRouteAction cannot contain any
    /// weightedBackendServices. Conversely, if routeAction specifies any
    /// weightedBackendServices, service must not be specified.  Only one of defaultService,
    /// defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultService")]
    #[builder(default)]
    pub default_service: Option<String>,
    /// When none of the specified hostRules match, the request is redirected to a URL specified
    /// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    /// defaultRouteAction must not be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUrlRedirect")]
    #[builder(default)]
    pub default_url_redirect: Option<RegionURLMapStatusAtProviderDefaultUrlRedirect>,
    /// An optional description of this resource. Provide this property when
    /// you create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Fingerprint of this resource. This field is used internally during
    /// updates of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fingerprint: Option<String>,
    /// The list of HostRules to use against the URL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRule")]
    #[builder(default)]
    pub host_rule: Option<Vec<RegionURLMapStatusAtProviderHostRule>>,
    /// an identifier for the resource with format projects/{{project}}/regions/{{region}}/urlMaps/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The unique identifier for the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mapId")]
    #[builder(default)]
    pub map_id: Option<f64>,
    /// The list of named PathMatchers to use against the URL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathMatcher")]
    #[builder(default)]
    pub path_matcher: Option<Vec<RegionURLMapStatusAtProviderPathMatcher>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The Region in which the url map should reside.
    /// If it is not provided, the provider region is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    /// The URI of the created resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLink")]
    #[builder(default)]
    pub self_link: Option<String>,
    /// The list of expected URL mappings. Requests to update this UrlMap will
    /// succeed only if all of the test cases pass.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub test: Option<Vec<RegionURLMapStatusAtProviderTest>>,
}

/// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
/// Only one of defaultRouteAction or defaultUrlRedirect must be set.
/// URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
/// defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see
    /// W3C Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<RegionURLMapStatusAtProviderDefaultRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
    /// As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
    /// Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
    /// timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
    /// Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: Routing and traffic management features.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<RegionURLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
    /// The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
    /// Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<RegionURLMapStatusAtProviderDefaultRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<RegionURLMapStatusAtProviderDefaultRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
    /// If not specified, this field uses the largest timeout among all backend services associated with the route.
    /// Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<RegionURLMapStatusAtProviderDefaultRouteActionTimeout>,
    /// The spec to modify the URL of the request, before forwarding the request to the matched service.
    /// urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
    /// Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<RegionURLMapStatusAtProviderDefaultRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match occurs. The weights determine the fraction of traffic that flows to their corresponding backend service. If all traffic needs to go to a single backend service, there must be one weightedBackendService with weight set to a non-zero number.
    /// After a backend service is identified and before forwarding the request to the backend service, advanced routing actions such as URL rewrites and header transformations are applied depending on additional settings specified in this HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<RegionURLMapStatusAtProviderDefaultRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see
/// W3C Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    /// which indicates that the CORS policy is in effect. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
/// As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
/// Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
/// timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
/// Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: Routing and traffic management features.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<RegionURLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<RegionURLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<RegionURLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
/// The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
/// Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionRequestMirrorPolicy {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<RegionURLMapStatusAtProviderDefaultRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
/// If not specified, this field uses the largest timeout among all backend services associated with the route.
/// Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, before forwarding the request to the matched service.
/// urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
/// Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionWeightedBackendServices {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<RegionURLMapStatusAtProviderDefaultRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<RegionURLMapStatusAtProviderDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<RegionURLMapStatusAtProviderDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// When none of the specified hostRules match, the request is redirected to a URL specified
/// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
/// defaultRouteAction must not be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderDefaultUrlRedirect {
    /// The host that will be used in the redirect response instead of the one that was
    /// supplied in the request. The value must be between 1 and 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https. If set to
    /// false, the URL scheme of the redirected request will remain the same as that of the
    /// request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    /// true for TargetHttpsProxy is not permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one that was
    /// supplied in the request. pathRedirect cannot be supplied together with
    /// prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    /// original request will be used for the redirect. The value must be between 1 and 1024
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    /// retaining the remaining portion of the URL before redirecting the request.
    /// prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    /// neither. If neither is supplied, the path of the original request will be used for
    /// the redirect. The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is removed prior
    /// to redirecting the request. If set to false, the query portion of the original URL is
    /// retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderHostRule {
    /// An optional description of this HostRule. Provide this property
    /// when you create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The list of host patterns to match. They must be valid
    /// hostnames, except * will match any string of ([a-z0-9-.]*). In
    /// that case, * must be the first character and must be followed in
    /// the pattern by either - or ..
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hosts: Option<Vec<String>>,
    /// The name of the PathMatcher to use to match the path portion of
    /// the URL if the hostRule matches the URL's host portion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathMatcher")]
    #[builder(default)]
    pub path_matcher: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcher {
    /// A reference to a RegionBackendService resource. This will be used if
    /// none of the pathRules defined by this PathMatcher is matched by
    /// the URL's path portion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultService")]
    #[builder(default)]
    pub default_service: Option<String>,
    /// When none of the specified hostRules match, the request is redirected to a URL specified
    /// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    /// defaultRouteAction must not be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUrlRedirect")]
    #[builder(default)]
    pub default_url_redirect: Option<RegionURLMapStatusAtProviderPathMatcherDefaultUrlRedirect>,
    /// An optional description of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The name to which this PathMatcher is referred by the HostRule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The list of path rules. Use this list instead of routeRules when routing based
    /// on simple path matching is all that's required. The order by which path rules
    /// are specified does not matter. Matches are always done on the longest-path-first
    /// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
    /// irrespective of the order in which those paths appear in this list. Within a
    /// given pathMatcher, only one of pathRules or routeRules must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRule")]
    #[builder(default)]
    pub path_rule: Option<Vec<RegionURLMapStatusAtProviderPathMatcherPathRule>>,
    /// The list of ordered HTTP route rules. Use this list instead of pathRules when
    /// advanced route matching and routing actions are desired. The order of specifying
    /// routeRules matters: the first rule that matches will cause its specified routing
    /// action to take effect. Within a given pathMatcher, only one of pathRules or
    /// routeRules must be set. routeRules are not supported in UrlMaps intended for
    /// External load balancers.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeRules")]
    #[builder(default)]
    pub route_rules: Option<Vec<RegionURLMapStatusAtProviderPathMatcherRouteRules>>,
}

/// When none of the specified hostRules match, the request is redirected to a URL specified
/// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
/// defaultRouteAction must not be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherDefaultUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained. The default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRule {
    /// The list of path patterns to match. Each must start with / and the only place a
    /// * is allowed is at the end following a /. The string fed to the path matcher
    /// does not include any text after the first ? or #, and those chars are not
    /// allowed here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paths: Option<Vec<String>>,
    /// In response to a matching matchRule, the load balancer performs advanced routing
    /// actions like URL rewrites, header transformations, etc. prior to forwarding the
    /// request to the selected backend. If  routeAction specifies any
    /// weightedBackendServices, service must not be set. Conversely if service is set,
    /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    /// or urlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAction")]
    #[builder(default)]
    pub route_action: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteAction>,
    /// A reference to expected RegionBackendService resource the given URL should be mapped to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// When this rule is matched, the request is redirected to a URL specified by
    /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
    /// set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRedirect")]
    #[builder(default)]
    pub url_redirect: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleUrlRedirect>,
}

/// In response to a matching matchRule, the load balancer performs advanced routing
/// actions like URL rewrites, header transformations, etc. prior to forwarding the
/// request to the selected backend. If  routeAction specifies any
/// weightedBackendServices, service must not be set. Conversely if service is set,
/// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
/// or urlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    /// which indicates that the CORS policy is in effect. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionRequestMirrorPolicy {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServices {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// When this rule is matched, the request is redirected to a URL specified by
/// urlRedirect. If urlRedirect is specified, service or routeAction must not be
/// set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherPathRuleUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained. The default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRules {
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesHeaderAction>,
    /// The rules for determining a match.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchRules")]
    #[builder(default)]
    pub match_rules: Option<Vec<RegionURLMapStatusAtProviderPathMatcherRouteRulesMatchRules>>,
    /// For routeRules within a given pathMatcher, priority determines the order
    /// in which load balancer will interpret routeRules. RouteRules are evaluated
    /// in order of priority, from the lowest to highest number. The priority of
    /// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
    /// that matches the request is applied.
    /// You cannot configure two or more routeRules with the same priority.
    /// Priority for each rule must be set to a number between 0 and
    /// 2147483647 inclusive.
    /// Priority numbers can have gaps, which enable you to add or remove rules
    /// in the future without affecting the rest of the rules. For example,
    /// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
    /// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
    /// future without any impact on existing rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub priority: Option<f64>,
    /// In response to a matching matchRule, the load balancer performs advanced routing
    /// actions like URL rewrites, header transformations, etc. prior to forwarding the
    /// request to the selected backend. If  routeAction specifies any
    /// weightedBackendServices, service must not be set. Conversely if service is set,
    /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    /// or urlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAction")]
    #[builder(default)]
    pub route_action: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteAction>,
    /// A reference to expected RegionBackendService resource the given URL should be mapped to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// When this rule is matched, the request is redirected to a URL specified by
    /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
    /// set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRedirect")]
    #[builder(default)]
    pub url_redirect: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesUrlRedirect>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<RegionURLMapStatusAtProviderPathMatcherRouteRulesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<RegionURLMapStatusAtProviderPathMatcherRouteRulesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesMatchRules {
    /// For satisfying the matchRule condition, the path of the request must exactly
    /// match the value specified in fullPathMatch after removing any query parameters
    /// and anchor that may be part of the original URL. FullPathMatch must be between 1
    /// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
    /// be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fullPathMatch")]
    #[builder(default)]
    pub full_path_match: Option<String>,
    /// Specifies a list of header match criteria, all of which must match corresponding
    /// headers in the request.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    #[builder(default)]
    pub header_matches: Option<Vec<RegionURLMapStatusAtProviderPathMatcherRouteRulesMatchRulesHeaderMatches>>,
    /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    #[builder(default)]
    pub ignore_case: Option<bool>,
    /// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
    /// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
    /// clients present node metadata. If a match takes place, the relevant routing
    /// configuration is made available to those proxies. For each metadataFilter in
    /// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
    /// filterLabels must match the corresponding label provided in the metadata. If its
    /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
    /// with corresponding labels in the provided metadata. metadataFilters specified
    /// here can be overrides those specified in ForwardingRule that refers to this
    /// UrlMap. metadataFilters only applies to Loadbalancers that have their
    /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataFilters")]
    #[builder(default)]
    pub metadata_filters: Option<Vec<RegionURLMapStatusAtProviderPathMatcherRouteRulesMatchRulesMetadataFilters>>,
    /// For satisfying the matchRule condition, the path of the request
    /// must match the wildcard pattern specified in pathTemplateMatch
    /// after removing any query parameters and anchor that may be part
    /// of the original URL.
    /// pathTemplateMatch must be between 1 and 255 characters
    /// (inclusive).  The pattern specified by pathTemplateMatch may
    /// have at most 5 wildcard operators and at most 5 variable
    /// captures in total.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTemplateMatch")]
    #[builder(default)]
    pub path_template_match: Option<String>,
    /// For satisfying the matchRule condition, the request's path must begin with the
    /// specified prefixMatch. prefixMatch must begin with a /. The value must be
    /// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
    /// regexMatch must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixMatch")]
    #[builder(default)]
    pub prefix_match: Option<String>,
    /// Specifies a list of query parameter match criteria, all of which must match
    /// corresponding query parameters in the request.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParameterMatches")]
    #[builder(default)]
    pub query_parameter_matches: Option<Vec<RegionURLMapStatusAtProviderPathMatcherRouteRulesMatchRulesQueryParameterMatches>>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesMatchRulesHeaderMatches {
    /// The queryParameterMatch matches if the value of the parameter exactly matches
    /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exactMatch")]
    #[builder(default)]
    pub exact_match: Option<String>,
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// If set to false, the headerMatch is considered a match if the match criteria
    /// above are met. If set to true, the headerMatch is considered a match if the
    /// match criteria above are NOT met. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertMatch")]
    #[builder(default)]
    pub invert_match: Option<bool>,
    /// For satisfying the matchRule condition, the request's path must begin with the
    /// specified prefixMatch. prefixMatch must begin with a /. The value must be
    /// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
    /// regexMatch must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixMatch")]
    #[builder(default)]
    pub prefix_match: Option<String>,
    /// Specifies that the queryParameterMatch matches if the request contains the query
    /// parameter, irrespective of whether the parameter has a value or not. Only one of
    /// presentMatch, exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "presentMatch")]
    #[builder(default)]
    pub present_match: Option<bool>,
    /// The header value must be an integer and its value must be in the range specified
    /// in rangeMatch. If the header does not contain an integer, number or is empty,
    /// the match fails. For example for a range [-5, 0]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeMatch")]
    #[builder(default)]
    pub range_match: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
    /// The value of the header must end with the contents of suffixMatch. Only one of
    /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "suffixMatch")]
    #[builder(default)]
    pub suffix_match: Option<String>,
}

/// The header value must be an integer and its value must be in the range specified
/// in rangeMatch. If the header does not contain an integer, number or is empty,
/// the match fails. For example for a range [-5, 0]
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch {
    /// The end of the range (exclusive).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeEnd")]
    #[builder(default)]
    pub range_end: Option<f64>,
    /// The start of the range (inclusive).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeStart")]
    #[builder(default)]
    pub range_start: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesMatchRulesMetadataFilters {
    /// The list of label value pairs that must match labels in the provided metadata
    /// based on filterMatchCriteria  This list must not be empty and can have at the
    /// most 64 entries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterLabels")]
    #[builder(default)]
    pub filter_labels: Option<Vec<RegionURLMapStatusAtProviderPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels>>,
    /// Specifies how individual filterLabel matches within the list of filterLabels
    /// contribute towards the overall metadataFilter match. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterMatchCriteria")]
    #[builder(default)]
    pub filter_match_criteria: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels {
    /// The name of the query parameter to match. The query parameter must exist in the
    /// request, in the absence of which the request match fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The value of the label must match the specified value. value can have a maximum
    /// length of 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesMatchRulesQueryParameterMatches {
    /// The queryParameterMatch matches if the value of the parameter exactly matches
    /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exactMatch")]
    #[builder(default)]
    pub exact_match: Option<String>,
    /// The name of the query parameter to match. The query parameter must exist in the
    /// request, in the absence of which the request match fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Specifies that the queryParameterMatch matches if the request contains the query
    /// parameter, irrespective of whether the parameter has a value or not. Only one of
    /// presentMatch, exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "presentMatch")]
    #[builder(default)]
    pub present_match: Option<bool>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
}

/// In response to a matching matchRule, the load balancer performs advanced routing
/// actions like URL rewrites, header transformations, etc. prior to forwarding the
/// request to the selected backend. If  routeAction specifies any
/// weightedBackendServices, service must not be set. Conversely if service is set,
/// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
/// or urlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    /// which indicates that the CORS policy is in effect. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionRequestMirrorPolicy {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected origin, if the
    /// request matched a pathTemplateMatch, the matching portion of the
    /// request's path is replaced re-written using the pattern specified
    /// by pathTemplateRewrite.
    /// pathTemplateRewrite must be between 1 and 255 characters
    /// (inclusive), must start with a '/', and must only use variables
    /// captured by the route's pathTemplate matchers.
    /// pathTemplateRewrite may only be used when all of a route's
    /// MatchRules specify pathTemplate.
    /// Only one of pathPrefixRewrite and pathTemplateRewrite may be
    /// specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTemplateRewrite")]
    #[builder(default)]
    pub path_template_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServices {
    /// The default RegionBackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// When this rule is matched, the request is redirected to a URL specified by
/// urlRedirect. If urlRedirect is specified, service or routeAction must not be
/// set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderPathMatcherRouteRulesUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained. The default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RegionURLMapStatusAtProviderTest {
    /// Description of this test case.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Host portion of the URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub host: Option<String>,
    /// Path portion of the URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// A reference to expected RegionBackendService resource the given URL should be mapped to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
}

