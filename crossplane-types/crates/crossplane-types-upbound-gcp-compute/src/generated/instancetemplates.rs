// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// InstanceTemplateSpec defines the desired state of InstanceTemplate
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta2", kind = "InstanceTemplate", plural = "instancetemplates")]
#[kube(status = "InstanceTemplateStatus")]
pub struct InstanceTemplateSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<InstanceTemplateDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: InstanceTemplateForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<InstanceTemplateInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<InstanceTemplateProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<InstanceTemplatePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<InstanceTemplateWriteConnectionSecretToRef>,
}

/// InstanceTemplateSpec defines the desired state of InstanceTemplate
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProvider {
    /// Configure Nested Virtualisation and Simultaneous Hyper Threading on this VM. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    #[builder(default)]
    pub advanced_machine_features: Option<InstanceTemplateForProviderAdvancedMachineFeatures>,
    /// Whether to allow sending and receiving of
    /// packets with non-matching source or destination IPs. This defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "canIpForward")]
    #[builder(default)]
    pub can_ip_forward: Option<bool>,
    /// Enable Confidential Mode on this VM. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceConfig")]
    #[builder(default)]
    pub confidential_instance_config: Option<InstanceTemplateForProviderConfidentialInstanceConfig>,
    /// A brief description of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Disks to attach to instances created from this template.
    /// This can be specified multiple times for multiple disks. Structure is
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disk: Option<Vec<InstanceTemplateForProviderDisk>>,
    /// List of the type and count of accelerator cards attached to the instance. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    #[builder(default)]
    pub guest_accelerator: Option<Vec<InstanceTemplateForProviderGuestAccelerator>>,
    /// A brief description to use for instances
    /// created from this template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceDescription")]
    #[builder(default)]
    pub instance_description: Option<String>,
    /// A set of key/value label pairs to assign to instances
    /// created from this template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The machine type to create.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    #[builder(default)]
    pub machine_type: Option<String>,
    /// Metadata key/value pairs to make available from
    /// within instances created from this template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
    /// An alternative to using the
    /// startup-script metadata key, mostly to match the compute_instance resource.
    /// This replaces the startup-script metadata key on the created instance and
    /// thus the two mechanisms are not allowed to be used simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataStartupScript")]
    #[builder(default)]
    pub metadata_startup_script: Option<String>,
    /// Specifies a minimum CPU platform. Applicable values are the friendly names of CPU platforms, such as
    /// Intel Haswell or Intel Skylake. See the complete list here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    #[builder(default)]
    pub min_cpu_platform: Option<String>,
    /// The name of the instance template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Creates a unique name beginning with the specified
    /// prefix. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namePrefix")]
    #[builder(default)]
    pub name_prefix: Option<String>,
    /// Networks to attach to instances created from
    /// this template. This can be specified multiple times for multiple networks.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterface")]
    #[builder(default)]
    pub network_interface: Option<Vec<InstanceTemplateForProviderNetworkInterface>>,
    /// os-features, and network_interface.0.nic-type must be GVNIC
    /// in order for this setting to take effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    #[builder(default)]
    pub network_performance_config: Option<InstanceTemplateForProviderNetworkPerformanceConfig>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// An instance template is a global resource that is not
    /// bound to a zone or a region. However, you can still specify some regional
    /// resources in an instance template, which restricts the template to the
    /// region where that resource resides. For example, a custom subnetwork
    /// resource is tied to a specific region. Defaults to the region of the
    /// Provider if no value is given.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    /// Specifies the reservations that this instance can consume from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    #[builder(default)]
    pub reservation_affinity: Option<InstanceTemplateForProviderReservationAffinity>,
    /// A set of key/value resource manager tag pairs to bind to the instances. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// - A list of self_links of resource policies to attach to the instance. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePolicies")]
    #[builder(default)]
    pub resource_policies: Option<Vec<String>>,
    /// The scheduling strategy to use. More details about
    /// this configuration option are detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scheduling: Option<InstanceTemplateForProviderScheduling>,
    /// Service account to attach to the instance. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<InstanceTemplateForProviderServiceAccount>,
    /// Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.
    /// Note: shielded_instance_config can only be used with boot images with shielded vm support. See the complete list here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    #[builder(default)]
    pub shielded_instance_config: Option<InstanceTemplateForProviderShieldedInstanceConfig>,
    /// Tags to attach to the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
}

/// Configure Nested Virtualisation and Simultaneous Hyper Threading on this VM. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderAdvancedMachineFeatures {
    /// Defines whether the instance should have nested virtualization enabled. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    #[builder(default)]
    pub enable_nested_virtualization: Option<bool>,
    /// The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    #[builder(default)]
    pub threads_per_core: Option<f64>,
    /// The number of physical cores to expose to an instance. visible cores info (VC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "visibleCoreCount")]
    #[builder(default)]
    pub visible_core_count: Option<f64>,
}

/// Enable Confidential Mode on this VM. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderConfidentialInstanceConfig {
    /// Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: SEV, SEV_SNP, TDX. on_host_maintenance can be set to MIGRATE if confidential_instance_type is set to SEV and min_cpu_platform is set to "AMD Milan". Otherwise, on_host_maintenance has to be set to TERMINATE or this will fail to create the VM. If SEV_SNP, currently min_cpu_platform has to be set to "AMD Milan" or this will fail to create the VM. TDX is only available in beta.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceType")]
    #[builder(default)]
    pub confidential_instance_type: Option<String>,
    /// Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, on_host_maintenance can be set to MIGRATE if min_cpu_platform is set to "AMD Milan". Otherwise, on_host_maintenance has to be set to TERMINATE or this will fail to create the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    #[builder(default)]
    pub enable_confidential_compute: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderDisk {
    /// Whether or not the disk should be auto-deleted.
    /// This defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    #[builder(default)]
    pub auto_delete: Option<bool>,
    /// Indicates that this is a boot disk.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub boot: Option<bool>,
    /// A unique device name that is reflected into the
    /// /dev/  tree of a Linux operating system running within the instance. If not
    /// specified, the server chooses a default device name to apply to this disk.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// Encrypts or decrypts a disk using a customer-supplied encryption key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKey")]
    #[builder(default)]
    pub disk_encryption_key: Option<InstanceTemplateForProviderDiskDiskEncryptionKey>,
    /// Name of the disk. When not provided, this defaults
    /// to the name of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskName")]
    #[builder(default)]
    pub disk_name: Option<String>,
    /// The size of the image in gigabytes. If not
    /// specified, it will inherit the size of its base image. For SCRATCH disks,
    /// the size must be exactly 375GB.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    #[builder(default)]
    pub disk_size_gb: Option<f64>,
    /// The GCE disk type. Such as "pd-ssd", "local-ssd",
    /// "pd-balanced" or "pd-standard", "hyperdisk-balanced", "hyperdisk-throughput" or "hyperdisk-extreme".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    #[builder(default)]
    pub disk_type: Option<String>,
    /// Specifies the disk interface to use for attaching this disk,
    /// which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
    /// and the request will fail if you attempt to attach a persistent disk in any other format
    /// than SCSI. Local SSDs can use either NVME or SCSI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub interface: Option<String>,
    /// A set of ket/value label pairs to assign to disk created from
    /// this template
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The mode in which to attach this disk, either READ_WRITE
    /// or READ_ONLY. If you are attaching or creating a boot disk, this must
    /// read-write mode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
    /// Indicates how many IOPS to provision for the disk. This
    /// sets the number of I/O operations per second that the disk can handle.
    /// Values must be between 10,000 and 120,000. For more details, see the
    /// Extreme persistent disk documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedIops")]
    #[builder(default)]
    pub provisioned_iops: Option<f64>,
    /// A set of key/value resource manager tag pairs to bind to this disk. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// - A list (short name or id) of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePolicies")]
    #[builder(default)]
    pub resource_policies: Option<Vec<String>>,
    /// References to ResourcePolicy in compute to populate resourcePolicies.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePoliciesRefs")]
    #[builder(default)]
    pub resource_policies_refs: Option<Vec<InstanceTemplateForProviderDiskResourcePoliciesRefs>>,
    /// Selector for a list of ResourcePolicy in compute to populate resourcePolicies.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePoliciesSelector")]
    #[builder(default)]
    pub resource_policies_selector: Option<InstanceTemplateForProviderDiskResourcePoliciesSelector>,
    /// The name (not self_link)
    /// of the disk (such as those managed by google_compute_disk) to attach.
    /// ~> Note: Either source, source_image, or source_snapshot is required in a disk block unless the disk type is local-ssd. Check the API docs for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<String>,
    /// The image from which to
    /// initialize this disk. This can be one of: the image's self_link,
    /// projects/{project}/global/images/{image},
    /// projects/{project}/global/images/family/{family}, global/images/{image},
    /// global/images/family/{family}, family/{family}, {project}/{family},
    /// {project}/{image}, {family}, or {image}.
    /// ~> Note: Either source, source_image, or source_snapshot is required in a disk block unless the disk type is local-ssd. Check the API docs for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceImage")]
    #[builder(default)]
    pub source_image: Option<String>,
    /// The customer-supplied encryption
    /// key of the source image. Required if the source image is protected by a
    /// customer-supplied encryption key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceImageEncryptionKey")]
    #[builder(default)]
    pub source_image_encryption_key: Option<InstanceTemplateForProviderDiskSourceImageEncryptionKey>,
    /// Reference to a Disk in compute to populate source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRef")]
    #[builder(default)]
    pub source_ref: Option<InstanceTemplateForProviderDiskSourceRef>,
    /// Selector for a Disk in compute to populate source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSelector")]
    #[builder(default)]
    pub source_selector: Option<InstanceTemplateForProviderDiskSourceSelector>,
    /// The source snapshot to create this disk.
    /// ~> Note: Either source, source_image, or source_snapshot is required in a disk block unless the disk type is local-ssd. Check the API docs for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSnapshot")]
    #[builder(default)]
    pub source_snapshot: Option<String>,
    /// The customer-supplied encryption
    /// key of the source snapshot. Structure
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSnapshotEncryptionKey")]
    #[builder(default)]
    pub source_snapshot_encryption_key: Option<InstanceTemplateForProviderDiskSourceSnapshotEncryptionKey>,
    /// The type of GCE disk, can be either "SCRATCH" or
    /// "PERSISTENT".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Encrypts or decrypts a disk using a customer-supplied encryption key.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderDiskDiskEncryptionKey {
    /// The self link of the encryption key that is
    /// stored in Google Cloud KMS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderDiskResourcePoliciesRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateForProviderDiskResourcePoliciesRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderDiskResourcePoliciesRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateForProviderDiskResourcePoliciesRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateForProviderDiskResourcePoliciesRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderDiskResourcePoliciesRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderDiskResourcePoliciesRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of ResourcePolicy in compute to populate resourcePolicies.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderDiskResourcePoliciesSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateForProviderDiskResourcePoliciesSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderDiskResourcePoliciesSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateForProviderDiskResourcePoliciesSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateForProviderDiskResourcePoliciesSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderDiskResourcePoliciesSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderDiskResourcePoliciesSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The customer-supplied encryption
/// key of the source image. Required if the source image is protected by a
/// customer-supplied encryption key.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderDiskSourceImageEncryptionKey {
    /// The self link of the encryption key that is
    /// stored in Google Cloud KMS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
    /// The service account being used for the
    /// encryption request for the given KMS key. If absent, the Compute Engine
    /// default service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyServiceAccount")]
    #[builder(default)]
    pub kms_key_service_account: Option<String>,
}

/// Reference to a Disk in compute to populate source.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderDiskSourceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateForProviderDiskSourceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderDiskSourceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateForProviderDiskSourceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateForProviderDiskSourceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderDiskSourceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderDiskSourceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Disk in compute to populate source.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderDiskSourceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateForProviderDiskSourceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderDiskSourceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateForProviderDiskSourceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateForProviderDiskSourceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderDiskSourceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderDiskSourceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The customer-supplied encryption
/// key of the source snapshot. Structure
/// documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderDiskSourceSnapshotEncryptionKey {
    /// The self link of the encryption key that is
    /// stored in Google Cloud KMS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
    /// The service account being used for the
    /// encryption request for the given KMS key. If absent, the Compute Engine
    /// default service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyServiceAccount")]
    #[builder(default)]
    pub kms_key_service_account: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderGuestAccelerator {
    /// The number of the guest accelerator cards exposed to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkInterface {
    /// Access configurations, i.e. IPs via which this
    /// instance can be accessed via the Internet.g. via tunnel or because it is running on another cloud instance
    /// on that network). This block can be repeated multiple times. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessConfig")]
    #[builder(default)]
    pub access_config: Option<Vec<InstanceTemplateForProviderNetworkInterfaceAccessConfig>>,
    /// An
    /// array of alias IP ranges for this network interface. Can only be specified for network
    /// interfaces on subnet-mode networks. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "aliasIpRange")]
    #[builder(default)]
    pub alias_ip_range: Option<Vec<InstanceTemplateForProviderNetworkInterfaceAliasIpRange>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIpv6PrefixLength")]
    #[builder(default)]
    pub internal_ipv6_prefix_length: Option<f64>,
    /// An array of IPv6 access configurations for this interface.
    /// Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
    /// specified, then this instance will have no external IPv6 Internet access. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AccessConfig")]
    #[builder(default)]
    pub ipv6_access_config: Option<Vec<InstanceTemplateForProviderNetworkInterfaceIpv6AccessConfig>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Address")]
    #[builder(default)]
    pub ipv6_address: Option<String>,
    /// The name or self_link of the network to attach this interface to.
    /// Use network attribute for Legacy or Auto subnetted networks and
    /// subnetwork for custom subnetted networks.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// The private IP address to assign to the instance. If
    /// empty, the address will be automatically assigned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkIp")]
    #[builder(default)]
    pub network_ip: Option<String>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    #[builder(default)]
    pub network_ref: Option<InstanceTemplateForProviderNetworkInterfaceNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    #[builder(default)]
    pub network_selector: Option<InstanceTemplateForProviderNetworkInterfaceNetworkSelector>,
    /// The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nicType")]
    #[builder(default)]
    pub nic_type: Option<String>,
    /// The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueCount")]
    #[builder(default)]
    pub queue_count: Option<f64>,
    /// The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6 or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    #[builder(default)]
    pub stack_type: Option<String>,
    /// the name of the subnetwork to attach this interface
    /// to. The subnetwork must exist in the same region this instance will be
    /// created in. Either network or subnetwork must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// The ID of the project in which the subnetwork belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkProject")]
    #[builder(default)]
    pub subnetwork_project: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    #[builder(default)]
    pub subnetwork_ref: Option<InstanceTemplateForProviderNetworkInterfaceSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    #[builder(default)]
    pub subnetwork_selector: Option<InstanceTemplateForProviderNetworkInterfaceSubnetworkSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkInterfaceAccessConfig {
    /// The IP address that will be 1:1 mapped to the instance's
    /// network ip. If not given, one will be generated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natIp")]
    #[builder(default)]
    pub nat_ip: Option<String>,
    /// The service-level to be provided for IPv6 traffic when the
    /// subnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkInterfaceAliasIpRange {
    /// The IP CIDR range represented by this alias IP range. This IP CIDR range
    /// must belong to the specified subnetwork and cannot contain IP addresses reserved by
    /// system or used by other network interfaces. At the time of writing only a
    /// netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
    /// error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipCidrRange")]
    #[builder(default)]
    pub ip_cidr_range: Option<String>,
    /// The subnetwork secondary range name specifying
    /// the secondary range from which to allocate the IP CIDR range for this alias IP
    /// range. If left unspecified, the primary range of the subnetwork will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRangeName")]
    #[builder(default)]
    pub subnetwork_range_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkInterfaceIpv6AccessConfig {
    /// The service-level to be provided for IPv6 traffic when the
    /// subnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkInterfaceNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateForProviderNetworkInterfaceNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkInterfaceNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateForProviderNetworkInterfaceNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateForProviderNetworkInterfaceNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderNetworkInterfaceNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderNetworkInterfaceNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkInterfaceNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateForProviderNetworkInterfaceNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkInterfaceNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateForProviderNetworkInterfaceNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateForProviderNetworkInterfaceNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderNetworkInterfaceNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderNetworkInterfaceNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkInterfaceSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateForProviderNetworkInterfaceSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkInterfaceSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateForProviderNetworkInterfaceSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateForProviderNetworkInterfaceSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderNetworkInterfaceSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderNetworkInterfaceSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkInterfaceSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateForProviderNetworkInterfaceSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkInterfaceSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateForProviderNetworkInterfaceSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateForProviderNetworkInterfaceSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderNetworkInterfaceSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderNetworkInterfaceSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// os-features, and network_interface.0.nic-type must be GVNIC
/// in order for this setting to take effect.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderNetworkPerformanceConfig {
    /// The egress bandwidth tier to enable. Possible values: TIER_1, DEFAULT
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    #[builder(default)]
    pub total_egress_bandwidth_tier: Option<String>,
}

/// Specifies the reservations that this instance can consume from.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderReservationAffinity {
    /// Specifies the label selector for the reservation to use..
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "specificReservation")]
    #[builder(default)]
    pub specific_reservation: Option<InstanceTemplateForProviderReservationAffinitySpecificReservation>,
    /// The type of reservation from which this instance can consume resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Specifies the label selector for the reservation to use..
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderReservationAffinitySpecificReservation {
    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// Corresponds to the label values of a reservation resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

/// The scheduling strategy to use. More details about
/// this configuration option are detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderScheduling {
    /// Specifies whether the instance should be
    /// automatically restarted if it is terminated by Compute Engine (not
    /// terminated by a user). This defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticRestart")]
    #[builder(default)]
    pub automatic_restart: Option<bool>,
    /// Describe the type of termination action for SPOT VM. Can be STOP or DELETE.  Read more on here
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTerminationAction")]
    #[builder(default)]
    pub instance_termination_action: Option<String>,
    /// io/docs/providers/google/guides/provider_versions.html) Specifies the maximum amount of time a Local Ssd Vm should wait while recovery of the Local Ssd state is attempted. Its value should be in between 0 and 168 hours with hour granularity and the default value being 1 hour. Structure is documented below.
    /// The local_ssd_recovery_timeout block supports:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdRecoveryTimeout")]
    #[builder(default)]
    pub local_ssd_recovery_timeout: Option<Vec<InstanceTemplateForProviderSchedulingLocalSsdRecoveryTimeout>>,
    /// The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in instance_termination_action. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRunDuration")]
    #[builder(default)]
    pub max_run_duration: Option<InstanceTemplateForProviderSchedulingMaxRunDuration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCpus")]
    #[builder(default)]
    pub min_node_cpus: Option<f64>,
    /// Specifies node affinities or anti-affinities
    /// to determine which sole-tenant nodes your instances and managed instance
    /// groups will use as host systems. Read more on sole-tenant node creation
    /// here.
    /// Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinities")]
    #[builder(default)]
    pub node_affinities: Option<Vec<InstanceTemplateForProviderSchedulingNodeAffinities>>,
    /// Defines the maintenance behavior for this
    /// instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onHostMaintenance")]
    #[builder(default)]
    pub on_host_maintenance: Option<String>,
    /// Specifies the action to be performed when the instance is terminated using max_run_duration and STOP instance_termination_action. Only support true discard_local_ssd at this point. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onInstanceStopAction")]
    #[builder(default)]
    pub on_instance_stop_action: Option<InstanceTemplateForProviderSchedulingOnInstanceStopAction>,
    /// Allows instance to be preempted. This defaults to
    /// false. Read more on this
    /// here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub preemptible: Option<bool>,
    /// Describe the type of preemptible VM. This field accepts the value STANDARD or SPOT. If the value is STANDARD, there will be no discount. If this   is set to SPOT,
    /// preemptible should be true and automatic_restart should be
    /// false. For more info about
    /// SPOT, read here
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisioningModel")]
    #[builder(default)]
    pub provisioning_model: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderSchedulingLocalSsdRecoveryTimeout {
    /// Span of time that's a fraction of a second at nanosecond
    /// resolution. Durations less than one second are represented with a 0
    /// seconds field and a positive nanos field. Must be from 0 to
    /// 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to
    /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
    /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in instance_termination_action. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderSchedulingMaxRunDuration {
    /// Span of time that's a fraction of a second at nanosecond
    /// resolution. Durations less than one second are represented with a 0
    /// seconds field and a positive nanos field. Must be from 0 to
    /// 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to
    /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
    /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderSchedulingNodeAffinities {
    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// The operator. Can be IN for node-affinities
    /// or NOT_IN for anti-affinities.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Corresponds to the label values of a reservation resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

/// Specifies the action to be performed when the instance is terminated using max_run_duration and STOP instance_termination_action. Only support true discard_local_ssd at this point. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderSchedulingOnInstanceStopAction {
    /// Whether to discard local SSDs attached to the VM while terminating using max_run_duration. Only supports true at this point.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discardLocalSsd")]
    #[builder(default)]
    pub discard_local_ssd: Option<bool>,
}

/// Service account to attach to the instance. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderServiceAccount {
    /// The service account e-mail address. If not given, the
    /// default Google Compute Engine service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub email: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate email.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emailRef")]
    #[builder(default)]
    pub email_ref: Option<InstanceTemplateForProviderServiceAccountEmailRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate email.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emailSelector")]
    #[builder(default)]
    pub email_selector: Option<InstanceTemplateForProviderServiceAccountEmailSelector>,
    /// A list of service scopes. Both OAuth2 URLs and gcloud
    /// short names are supported. To allow full access to all Cloud APIs, use the
    /// cloud-platform scope. See a complete list of scopes here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scopes: Option<Vec<String>>,
}

/// Reference to a ServiceAccount in cloudplatform to populate email.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderServiceAccountEmailRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateForProviderServiceAccountEmailRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderServiceAccountEmailRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateForProviderServiceAccountEmailRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateForProviderServiceAccountEmailRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderServiceAccountEmailRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderServiceAccountEmailRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate email.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderServiceAccountEmailSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateForProviderServiceAccountEmailSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderServiceAccountEmailSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateForProviderServiceAccountEmailSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateForProviderServiceAccountEmailSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderServiceAccountEmailSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateForProviderServiceAccountEmailSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.
/// Note: shielded_instance_config can only be used with boot images with shielded vm support. See the complete list here.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateForProviderShieldedInstanceConfig {
    /// - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    #[builder(default)]
    pub enable_integrity_monitoring: Option<bool>,
    /// - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    #[builder(default)]
    pub enable_secure_boot: Option<bool>,
    /// - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableVtpm")]
    #[builder(default)]
    pub enable_vtpm: Option<bool>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProvider {
    /// Configure Nested Virtualisation and Simultaneous Hyper Threading on this VM. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    #[builder(default)]
    pub advanced_machine_features: Option<InstanceTemplateInitProviderAdvancedMachineFeatures>,
    /// Whether to allow sending and receiving of
    /// packets with non-matching source or destination IPs. This defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "canIpForward")]
    #[builder(default)]
    pub can_ip_forward: Option<bool>,
    /// Enable Confidential Mode on this VM. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceConfig")]
    #[builder(default)]
    pub confidential_instance_config: Option<InstanceTemplateInitProviderConfidentialInstanceConfig>,
    /// A brief description of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Disks to attach to instances created from this template.
    /// This can be specified multiple times for multiple disks. Structure is
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disk: Option<Vec<InstanceTemplateInitProviderDisk>>,
    /// List of the type and count of accelerator cards attached to the instance. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    #[builder(default)]
    pub guest_accelerator: Option<Vec<InstanceTemplateInitProviderGuestAccelerator>>,
    /// A brief description to use for instances
    /// created from this template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceDescription")]
    #[builder(default)]
    pub instance_description: Option<String>,
    /// A set of key/value label pairs to assign to instances
    /// created from this template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The machine type to create.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    #[builder(default)]
    pub machine_type: Option<String>,
    /// Metadata key/value pairs to make available from
    /// within instances created from this template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
    /// An alternative to using the
    /// startup-script metadata key, mostly to match the compute_instance resource.
    /// This replaces the startup-script metadata key on the created instance and
    /// thus the two mechanisms are not allowed to be used simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataStartupScript")]
    #[builder(default)]
    pub metadata_startup_script: Option<String>,
    /// Specifies a minimum CPU platform. Applicable values are the friendly names of CPU platforms, such as
    /// Intel Haswell or Intel Skylake. See the complete list here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    #[builder(default)]
    pub min_cpu_platform: Option<String>,
    /// The name of the instance template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Creates a unique name beginning with the specified
    /// prefix. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namePrefix")]
    #[builder(default)]
    pub name_prefix: Option<String>,
    /// Networks to attach to instances created from
    /// this template. This can be specified multiple times for multiple networks.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterface")]
    #[builder(default)]
    pub network_interface: Option<Vec<InstanceTemplateInitProviderNetworkInterface>>,
    /// os-features, and network_interface.0.nic-type must be GVNIC
    /// in order for this setting to take effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    #[builder(default)]
    pub network_performance_config: Option<InstanceTemplateInitProviderNetworkPerformanceConfig>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// An instance template is a global resource that is not
    /// bound to a zone or a region. However, you can still specify some regional
    /// resources in an instance template, which restricts the template to the
    /// region where that resource resides. For example, a custom subnetwork
    /// resource is tied to a specific region. Defaults to the region of the
    /// Provider if no value is given.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    /// Specifies the reservations that this instance can consume from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    #[builder(default)]
    pub reservation_affinity: Option<InstanceTemplateInitProviderReservationAffinity>,
    /// A set of key/value resource manager tag pairs to bind to the instances. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// - A list of self_links of resource policies to attach to the instance. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePolicies")]
    #[builder(default)]
    pub resource_policies: Option<Vec<String>>,
    /// The scheduling strategy to use. More details about
    /// this configuration option are detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scheduling: Option<InstanceTemplateInitProviderScheduling>,
    /// Service account to attach to the instance. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<InstanceTemplateInitProviderServiceAccount>,
    /// Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.
    /// Note: shielded_instance_config can only be used with boot images with shielded vm support. See the complete list here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    #[builder(default)]
    pub shielded_instance_config: Option<InstanceTemplateInitProviderShieldedInstanceConfig>,
    /// Tags to attach to the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
}

/// Configure Nested Virtualisation and Simultaneous Hyper Threading on this VM. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderAdvancedMachineFeatures {
    /// Defines whether the instance should have nested virtualization enabled. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    #[builder(default)]
    pub enable_nested_virtualization: Option<bool>,
    /// The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    #[builder(default)]
    pub threads_per_core: Option<f64>,
    /// The number of physical cores to expose to an instance. visible cores info (VC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "visibleCoreCount")]
    #[builder(default)]
    pub visible_core_count: Option<f64>,
}

/// Enable Confidential Mode on this VM. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderConfidentialInstanceConfig {
    /// Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: SEV, SEV_SNP, TDX. on_host_maintenance can be set to MIGRATE if confidential_instance_type is set to SEV and min_cpu_platform is set to "AMD Milan". Otherwise, on_host_maintenance has to be set to TERMINATE or this will fail to create the VM. If SEV_SNP, currently min_cpu_platform has to be set to "AMD Milan" or this will fail to create the VM. TDX is only available in beta.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceType")]
    #[builder(default)]
    pub confidential_instance_type: Option<String>,
    /// Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, on_host_maintenance can be set to MIGRATE if min_cpu_platform is set to "AMD Milan". Otherwise, on_host_maintenance has to be set to TERMINATE or this will fail to create the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    #[builder(default)]
    pub enable_confidential_compute: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderDisk {
    /// Whether or not the disk should be auto-deleted.
    /// This defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    #[builder(default)]
    pub auto_delete: Option<bool>,
    /// Indicates that this is a boot disk.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub boot: Option<bool>,
    /// A unique device name that is reflected into the
    /// /dev/  tree of a Linux operating system running within the instance. If not
    /// specified, the server chooses a default device name to apply to this disk.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// Encrypts or decrypts a disk using a customer-supplied encryption key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKey")]
    #[builder(default)]
    pub disk_encryption_key: Option<InstanceTemplateInitProviderDiskDiskEncryptionKey>,
    /// Name of the disk. When not provided, this defaults
    /// to the name of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskName")]
    #[builder(default)]
    pub disk_name: Option<String>,
    /// The size of the image in gigabytes. If not
    /// specified, it will inherit the size of its base image. For SCRATCH disks,
    /// the size must be exactly 375GB.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    #[builder(default)]
    pub disk_size_gb: Option<f64>,
    /// The GCE disk type. Such as "pd-ssd", "local-ssd",
    /// "pd-balanced" or "pd-standard", "hyperdisk-balanced", "hyperdisk-throughput" or "hyperdisk-extreme".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    #[builder(default)]
    pub disk_type: Option<String>,
    /// Specifies the disk interface to use for attaching this disk,
    /// which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
    /// and the request will fail if you attempt to attach a persistent disk in any other format
    /// than SCSI. Local SSDs can use either NVME or SCSI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub interface: Option<String>,
    /// A set of ket/value label pairs to assign to disk created from
    /// this template
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The mode in which to attach this disk, either READ_WRITE
    /// or READ_ONLY. If you are attaching or creating a boot disk, this must
    /// read-write mode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
    /// Indicates how many IOPS to provision for the disk. This
    /// sets the number of I/O operations per second that the disk can handle.
    /// Values must be between 10,000 and 120,000. For more details, see the
    /// Extreme persistent disk documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedIops")]
    #[builder(default)]
    pub provisioned_iops: Option<f64>,
    /// A set of key/value resource manager tag pairs to bind to this disk. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// - A list (short name or id) of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePolicies")]
    #[builder(default)]
    pub resource_policies: Option<Vec<String>>,
    /// References to ResourcePolicy in compute to populate resourcePolicies.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePoliciesRefs")]
    #[builder(default)]
    pub resource_policies_refs: Option<Vec<InstanceTemplateInitProviderDiskResourcePoliciesRefs>>,
    /// Selector for a list of ResourcePolicy in compute to populate resourcePolicies.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePoliciesSelector")]
    #[builder(default)]
    pub resource_policies_selector: Option<InstanceTemplateInitProviderDiskResourcePoliciesSelector>,
    /// The name (not self_link)
    /// of the disk (such as those managed by google_compute_disk) to attach.
    /// ~> Note: Either source, source_image, or source_snapshot is required in a disk block unless the disk type is local-ssd. Check the API docs for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<String>,
    /// The image from which to
    /// initialize this disk. This can be one of: the image's self_link,
    /// projects/{project}/global/images/{image},
    /// projects/{project}/global/images/family/{family}, global/images/{image},
    /// global/images/family/{family}, family/{family}, {project}/{family},
    /// {project}/{image}, {family}, or {image}.
    /// ~> Note: Either source, source_image, or source_snapshot is required in a disk block unless the disk type is local-ssd. Check the API docs for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceImage")]
    #[builder(default)]
    pub source_image: Option<String>,
    /// The customer-supplied encryption
    /// key of the source image. Required if the source image is protected by a
    /// customer-supplied encryption key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceImageEncryptionKey")]
    #[builder(default)]
    pub source_image_encryption_key: Option<InstanceTemplateInitProviderDiskSourceImageEncryptionKey>,
    /// Reference to a Disk in compute to populate source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRef")]
    #[builder(default)]
    pub source_ref: Option<InstanceTemplateInitProviderDiskSourceRef>,
    /// Selector for a Disk in compute to populate source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSelector")]
    #[builder(default)]
    pub source_selector: Option<InstanceTemplateInitProviderDiskSourceSelector>,
    /// The source snapshot to create this disk.
    /// ~> Note: Either source, source_image, or source_snapshot is required in a disk block unless the disk type is local-ssd. Check the API docs for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSnapshot")]
    #[builder(default)]
    pub source_snapshot: Option<String>,
    /// The customer-supplied encryption
    /// key of the source snapshot. Structure
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSnapshotEncryptionKey")]
    #[builder(default)]
    pub source_snapshot_encryption_key: Option<InstanceTemplateInitProviderDiskSourceSnapshotEncryptionKey>,
    /// The type of GCE disk, can be either "SCRATCH" or
    /// "PERSISTENT".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Encrypts or decrypts a disk using a customer-supplied encryption key.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderDiskDiskEncryptionKey {
    /// The self link of the encryption key that is
    /// stored in Google Cloud KMS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderDiskResourcePoliciesRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateInitProviderDiskResourcePoliciesRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderDiskResourcePoliciesRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateInitProviderDiskResourcePoliciesRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateInitProviderDiskResourcePoliciesRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderDiskResourcePoliciesRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderDiskResourcePoliciesRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of ResourcePolicy in compute to populate resourcePolicies.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderDiskResourcePoliciesSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateInitProviderDiskResourcePoliciesSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderDiskResourcePoliciesSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateInitProviderDiskResourcePoliciesSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateInitProviderDiskResourcePoliciesSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderDiskResourcePoliciesSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderDiskResourcePoliciesSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The customer-supplied encryption
/// key of the source image. Required if the source image is protected by a
/// customer-supplied encryption key.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderDiskSourceImageEncryptionKey {
    /// The self link of the encryption key that is
    /// stored in Google Cloud KMS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
    /// The service account being used for the
    /// encryption request for the given KMS key. If absent, the Compute Engine
    /// default service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyServiceAccount")]
    #[builder(default)]
    pub kms_key_service_account: Option<String>,
}

/// Reference to a Disk in compute to populate source.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderDiskSourceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateInitProviderDiskSourceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderDiskSourceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateInitProviderDiskSourceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateInitProviderDiskSourceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderDiskSourceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderDiskSourceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Disk in compute to populate source.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderDiskSourceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateInitProviderDiskSourceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderDiskSourceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateInitProviderDiskSourceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateInitProviderDiskSourceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderDiskSourceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderDiskSourceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The customer-supplied encryption
/// key of the source snapshot. Structure
/// documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderDiskSourceSnapshotEncryptionKey {
    /// The self link of the encryption key that is
    /// stored in Google Cloud KMS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
    /// The service account being used for the
    /// encryption request for the given KMS key. If absent, the Compute Engine
    /// default service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyServiceAccount")]
    #[builder(default)]
    pub kms_key_service_account: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderGuestAccelerator {
    /// The number of the guest accelerator cards exposed to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkInterface {
    /// Access configurations, i.e. IPs via which this
    /// instance can be accessed via the Internet.g. via tunnel or because it is running on another cloud instance
    /// on that network). This block can be repeated multiple times. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessConfig")]
    #[builder(default)]
    pub access_config: Option<Vec<InstanceTemplateInitProviderNetworkInterfaceAccessConfig>>,
    /// An
    /// array of alias IP ranges for this network interface. Can only be specified for network
    /// interfaces on subnet-mode networks. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "aliasIpRange")]
    #[builder(default)]
    pub alias_ip_range: Option<Vec<InstanceTemplateInitProviderNetworkInterfaceAliasIpRange>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIpv6PrefixLength")]
    #[builder(default)]
    pub internal_ipv6_prefix_length: Option<f64>,
    /// An array of IPv6 access configurations for this interface.
    /// Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
    /// specified, then this instance will have no external IPv6 Internet access. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AccessConfig")]
    #[builder(default)]
    pub ipv6_access_config: Option<Vec<InstanceTemplateInitProviderNetworkInterfaceIpv6AccessConfig>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Address")]
    #[builder(default)]
    pub ipv6_address: Option<String>,
    /// The name or self_link of the network to attach this interface to.
    /// Use network attribute for Legacy or Auto subnetted networks and
    /// subnetwork for custom subnetted networks.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// The private IP address to assign to the instance. If
    /// empty, the address will be automatically assigned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkIp")]
    #[builder(default)]
    pub network_ip: Option<String>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    #[builder(default)]
    pub network_ref: Option<InstanceTemplateInitProviderNetworkInterfaceNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    #[builder(default)]
    pub network_selector: Option<InstanceTemplateInitProviderNetworkInterfaceNetworkSelector>,
    /// The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nicType")]
    #[builder(default)]
    pub nic_type: Option<String>,
    /// The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueCount")]
    #[builder(default)]
    pub queue_count: Option<f64>,
    /// The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6 or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    #[builder(default)]
    pub stack_type: Option<String>,
    /// the name of the subnetwork to attach this interface
    /// to. The subnetwork must exist in the same region this instance will be
    /// created in. Either network or subnetwork must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// The ID of the project in which the subnetwork belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkProject")]
    #[builder(default)]
    pub subnetwork_project: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    #[builder(default)]
    pub subnetwork_ref: Option<InstanceTemplateInitProviderNetworkInterfaceSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    #[builder(default)]
    pub subnetwork_selector: Option<InstanceTemplateInitProviderNetworkInterfaceSubnetworkSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkInterfaceAccessConfig {
    /// The IP address that will be 1:1 mapped to the instance's
    /// network ip. If not given, one will be generated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natIp")]
    #[builder(default)]
    pub nat_ip: Option<String>,
    /// The service-level to be provided for IPv6 traffic when the
    /// subnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkInterfaceAliasIpRange {
    /// The IP CIDR range represented by this alias IP range. This IP CIDR range
    /// must belong to the specified subnetwork and cannot contain IP addresses reserved by
    /// system or used by other network interfaces. At the time of writing only a
    /// netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
    /// error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipCidrRange")]
    #[builder(default)]
    pub ip_cidr_range: Option<String>,
    /// The subnetwork secondary range name specifying
    /// the secondary range from which to allocate the IP CIDR range for this alias IP
    /// range. If left unspecified, the primary range of the subnetwork will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRangeName")]
    #[builder(default)]
    pub subnetwork_range_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkInterfaceIpv6AccessConfig {
    /// The service-level to be provided for IPv6 traffic when the
    /// subnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkInterfaceNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateInitProviderNetworkInterfaceNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkInterfaceNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateInitProviderNetworkInterfaceNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateInitProviderNetworkInterfaceNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderNetworkInterfaceNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderNetworkInterfaceNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkInterfaceNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateInitProviderNetworkInterfaceNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkInterfaceNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateInitProviderNetworkInterfaceNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateInitProviderNetworkInterfaceNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderNetworkInterfaceNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderNetworkInterfaceNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkInterfaceSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateInitProviderNetworkInterfaceSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkInterfaceSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateInitProviderNetworkInterfaceSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateInitProviderNetworkInterfaceSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderNetworkInterfaceSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderNetworkInterfaceSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkInterfaceSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateInitProviderNetworkInterfaceSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkInterfaceSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateInitProviderNetworkInterfaceSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateInitProviderNetworkInterfaceSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderNetworkInterfaceSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderNetworkInterfaceSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// os-features, and network_interface.0.nic-type must be GVNIC
/// in order for this setting to take effect.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderNetworkPerformanceConfig {
    /// The egress bandwidth tier to enable. Possible values: TIER_1, DEFAULT
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    #[builder(default)]
    pub total_egress_bandwidth_tier: Option<String>,
}

/// Specifies the reservations that this instance can consume from.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderReservationAffinity {
    /// Specifies the label selector for the reservation to use..
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "specificReservation")]
    #[builder(default)]
    pub specific_reservation: Option<InstanceTemplateInitProviderReservationAffinitySpecificReservation>,
    /// The type of reservation from which this instance can consume resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Specifies the label selector for the reservation to use..
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderReservationAffinitySpecificReservation {
    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// Corresponds to the label values of a reservation resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

/// The scheduling strategy to use. More details about
/// this configuration option are detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderScheduling {
    /// Specifies whether the instance should be
    /// automatically restarted if it is terminated by Compute Engine (not
    /// terminated by a user). This defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticRestart")]
    #[builder(default)]
    pub automatic_restart: Option<bool>,
    /// Describe the type of termination action for SPOT VM. Can be STOP or DELETE.  Read more on here
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTerminationAction")]
    #[builder(default)]
    pub instance_termination_action: Option<String>,
    /// io/docs/providers/google/guides/provider_versions.html) Specifies the maximum amount of time a Local Ssd Vm should wait while recovery of the Local Ssd state is attempted. Its value should be in between 0 and 168 hours with hour granularity and the default value being 1 hour. Structure is documented below.
    /// The local_ssd_recovery_timeout block supports:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdRecoveryTimeout")]
    #[builder(default)]
    pub local_ssd_recovery_timeout: Option<Vec<InstanceTemplateInitProviderSchedulingLocalSsdRecoveryTimeout>>,
    /// The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in instance_termination_action. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRunDuration")]
    #[builder(default)]
    pub max_run_duration: Option<InstanceTemplateInitProviderSchedulingMaxRunDuration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCpus")]
    #[builder(default)]
    pub min_node_cpus: Option<f64>,
    /// Specifies node affinities or anti-affinities
    /// to determine which sole-tenant nodes your instances and managed instance
    /// groups will use as host systems. Read more on sole-tenant node creation
    /// here.
    /// Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinities")]
    #[builder(default)]
    pub node_affinities: Option<Vec<InstanceTemplateInitProviderSchedulingNodeAffinities>>,
    /// Defines the maintenance behavior for this
    /// instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onHostMaintenance")]
    #[builder(default)]
    pub on_host_maintenance: Option<String>,
    /// Specifies the action to be performed when the instance is terminated using max_run_duration and STOP instance_termination_action. Only support true discard_local_ssd at this point. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onInstanceStopAction")]
    #[builder(default)]
    pub on_instance_stop_action: Option<InstanceTemplateInitProviderSchedulingOnInstanceStopAction>,
    /// Allows instance to be preempted. This defaults to
    /// false. Read more on this
    /// here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub preemptible: Option<bool>,
    /// Describe the type of preemptible VM. This field accepts the value STANDARD or SPOT. If the value is STANDARD, there will be no discount. If this   is set to SPOT,
    /// preemptible should be true and automatic_restart should be
    /// false. For more info about
    /// SPOT, read here
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisioningModel")]
    #[builder(default)]
    pub provisioning_model: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderSchedulingLocalSsdRecoveryTimeout {
    /// Span of time that's a fraction of a second at nanosecond
    /// resolution. Durations less than one second are represented with a 0
    /// seconds field and a positive nanos field. Must be from 0 to
    /// 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to
    /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
    /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in instance_termination_action. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderSchedulingMaxRunDuration {
    /// Span of time that's a fraction of a second at nanosecond
    /// resolution. Durations less than one second are represented with a 0
    /// seconds field and a positive nanos field. Must be from 0 to
    /// 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to
    /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
    /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderSchedulingNodeAffinities {
    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// The operator. Can be IN for node-affinities
    /// or NOT_IN for anti-affinities.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Corresponds to the label values of a reservation resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

/// Specifies the action to be performed when the instance is terminated using max_run_duration and STOP instance_termination_action. Only support true discard_local_ssd at this point. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderSchedulingOnInstanceStopAction {
    /// Whether to discard local SSDs attached to the VM while terminating using max_run_duration. Only supports true at this point.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discardLocalSsd")]
    #[builder(default)]
    pub discard_local_ssd: Option<bool>,
}

/// Service account to attach to the instance. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderServiceAccount {
    /// The service account e-mail address. If not given, the
    /// default Google Compute Engine service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub email: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate email.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emailRef")]
    #[builder(default)]
    pub email_ref: Option<InstanceTemplateInitProviderServiceAccountEmailRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate email.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emailSelector")]
    #[builder(default)]
    pub email_selector: Option<InstanceTemplateInitProviderServiceAccountEmailSelector>,
    /// A list of service scopes. Both OAuth2 URLs and gcloud
    /// short names are supported. To allow full access to all Cloud APIs, use the
    /// cloud-platform scope. See a complete list of scopes here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scopes: Option<Vec<String>>,
}

/// Reference to a ServiceAccount in cloudplatform to populate email.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderServiceAccountEmailRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateInitProviderServiceAccountEmailRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderServiceAccountEmailRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateInitProviderServiceAccountEmailRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateInitProviderServiceAccountEmailRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderServiceAccountEmailRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderServiceAccountEmailRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate email.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderServiceAccountEmailSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateInitProviderServiceAccountEmailSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderServiceAccountEmailSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateInitProviderServiceAccountEmailSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateInitProviderServiceAccountEmailSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderServiceAccountEmailSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateInitProviderServiceAccountEmailSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.
/// Note: shielded_instance_config can only be used with boot images with shielded vm support. See the complete list here.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateInitProviderShieldedInstanceConfig {
    /// - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    #[builder(default)]
    pub enable_integrity_monitoring: Option<bool>,
    /// - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    #[builder(default)]
    pub enable_secure_boot: Option<bool>,
    /// - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableVtpm")]
    #[builder(default)]
    pub enable_vtpm: Option<bool>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplateProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplateProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplateProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplateProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplatePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<InstanceTemplatePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<InstanceTemplatePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplatePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceTemplatePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplatePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceTemplatePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceTemplatePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplatePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceTemplatePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplatePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// InstanceTemplateStatus defines the observed state of InstanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<InstanceTemplateStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProvider {
    /// Configure Nested Virtualisation and Simultaneous Hyper Threading on this VM. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    #[builder(default)]
    pub advanced_machine_features: Option<InstanceTemplateStatusAtProviderAdvancedMachineFeatures>,
    /// Whether to allow sending and receiving of
    /// packets with non-matching source or destination IPs. This defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "canIpForward")]
    #[builder(default)]
    pub can_ip_forward: Option<bool>,
    /// Enable Confidential Mode on this VM. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceConfig")]
    #[builder(default)]
    pub confidential_instance_config: Option<InstanceTemplateStatusAtProviderConfidentialInstanceConfig>,
    /// A brief description of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Disks to attach to instances created from this template.
    /// This can be specified multiple times for multiple disks. Structure is
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disk: Option<Vec<InstanceTemplateStatusAtProviderDisk>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveLabels")]
    #[builder(default)]
    pub effective_labels: Option<HashMap<String, String>>,
    /// List of the type and count of accelerator cards attached to the instance. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    #[builder(default)]
    pub guest_accelerator: Option<Vec<InstanceTemplateStatusAtProviderGuestAccelerator>>,
    /// an identifier for the resource with format projects/{{project}}/global/instanceTemplates/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// A brief description to use for instances
    /// created from this template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceDescription")]
    #[builder(default)]
    pub instance_description: Option<String>,
    /// A set of key/value label pairs to assign to instances
    /// created from this template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The machine type to create.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    #[builder(default)]
    pub machine_type: Option<String>,
    /// Metadata key/value pairs to make available from
    /// within instances created from this template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
    /// The unique fingerprint of the metadata.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataFingerprint")]
    #[builder(default)]
    pub metadata_fingerprint: Option<String>,
    /// An alternative to using the
    /// startup-script metadata key, mostly to match the compute_instance resource.
    /// This replaces the startup-script metadata key on the created instance and
    /// thus the two mechanisms are not allowed to be used simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataStartupScript")]
    #[builder(default)]
    pub metadata_startup_script: Option<String>,
    /// Specifies a minimum CPU platform. Applicable values are the friendly names of CPU platforms, such as
    /// Intel Haswell or Intel Skylake. See the complete list here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    #[builder(default)]
    pub min_cpu_platform: Option<String>,
    /// The name of the instance template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Creates a unique name beginning with the specified
    /// prefix. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namePrefix")]
    #[builder(default)]
    pub name_prefix: Option<String>,
    /// Networks to attach to instances created from
    /// this template. This can be specified multiple times for multiple networks.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterface")]
    #[builder(default)]
    pub network_interface: Option<Vec<InstanceTemplateStatusAtProviderNetworkInterface>>,
    /// os-features, and network_interface.0.nic-type must be GVNIC
    /// in order for this setting to take effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    #[builder(default)]
    pub network_performance_config: Option<InstanceTemplateStatusAtProviderNetworkPerformanceConfig>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// An instance template is a global resource that is not
    /// bound to a zone or a region. However, you can still specify some regional
    /// resources in an instance template, which restricts the template to the
    /// region where that resource resides. For example, a custom subnetwork
    /// resource is tied to a specific region. Defaults to the region of the
    /// Provider if no value is given.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    /// Specifies the reservations that this instance can consume from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    #[builder(default)]
    pub reservation_affinity: Option<InstanceTemplateStatusAtProviderReservationAffinity>,
    /// A set of key/value resource manager tag pairs to bind to the instances. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// - A list of self_links of resource policies to attach to the instance. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePolicies")]
    #[builder(default)]
    pub resource_policies: Option<Vec<String>>,
    /// The scheduling strategy to use. More details about
    /// this configuration option are detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scheduling: Option<InstanceTemplateStatusAtProviderScheduling>,
    /// The URI of the created resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLink")]
    #[builder(default)]
    pub self_link: Option<String>,
    /// A special URI of the created resource that uniquely identifies this instance template with the following format: projects/{{project}}/global/instanceTemplates/{{name}}?uniqueId={{uniqueId}}
    /// Referencing an instance template via this attribute prevents Time of Check to Time of Use attacks when the instance template resides in a shared/untrusted environment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLinkUnique")]
    #[builder(default)]
    pub self_link_unique: Option<String>,
    /// Service account to attach to the instance. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<InstanceTemplateStatusAtProviderServiceAccount>,
    /// Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.
    /// Note: shielded_instance_config can only be used with boot images with shielded vm support. See the complete list here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    #[builder(default)]
    pub shielded_instance_config: Option<InstanceTemplateStatusAtProviderShieldedInstanceConfig>,
    /// Tags to attach to the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    /// The unique fingerprint of the tags.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsFingerprint")]
    #[builder(default)]
    pub tags_fingerprint: Option<String>,
    /// The combination of labels configured directly on the resource and default labels configured on the provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terraformLabels")]
    #[builder(default)]
    pub terraform_labels: Option<HashMap<String, String>>,
}

/// Configure Nested Virtualisation and Simultaneous Hyper Threading on this VM. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderAdvancedMachineFeatures {
    /// Defines whether the instance should have nested virtualization enabled. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    #[builder(default)]
    pub enable_nested_virtualization: Option<bool>,
    /// The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    #[builder(default)]
    pub threads_per_core: Option<f64>,
    /// The number of physical cores to expose to an instance. visible cores info (VC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "visibleCoreCount")]
    #[builder(default)]
    pub visible_core_count: Option<f64>,
}

/// Enable Confidential Mode on this VM. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderConfidentialInstanceConfig {
    /// Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: SEV, SEV_SNP, TDX. on_host_maintenance can be set to MIGRATE if confidential_instance_type is set to SEV and min_cpu_platform is set to "AMD Milan". Otherwise, on_host_maintenance has to be set to TERMINATE or this will fail to create the VM. If SEV_SNP, currently min_cpu_platform has to be set to "AMD Milan" or this will fail to create the VM. TDX is only available in beta.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceType")]
    #[builder(default)]
    pub confidential_instance_type: Option<String>,
    /// Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, on_host_maintenance can be set to MIGRATE if min_cpu_platform is set to "AMD Milan". Otherwise, on_host_maintenance has to be set to TERMINATE or this will fail to create the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    #[builder(default)]
    pub enable_confidential_compute: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderDisk {
    /// Whether or not the disk should be auto-deleted.
    /// This defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    #[builder(default)]
    pub auto_delete: Option<bool>,
    /// Indicates that this is a boot disk.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub boot: Option<bool>,
    /// A unique device name that is reflected into the
    /// /dev/  tree of a Linux operating system running within the instance. If not
    /// specified, the server chooses a default device name to apply to this disk.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// Encrypts or decrypts a disk using a customer-supplied encryption key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKey")]
    #[builder(default)]
    pub disk_encryption_key: Option<InstanceTemplateStatusAtProviderDiskDiskEncryptionKey>,
    /// Name of the disk. When not provided, this defaults
    /// to the name of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskName")]
    #[builder(default)]
    pub disk_name: Option<String>,
    /// The size of the image in gigabytes. If not
    /// specified, it will inherit the size of its base image. For SCRATCH disks,
    /// the size must be exactly 375GB.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    #[builder(default)]
    pub disk_size_gb: Option<f64>,
    /// The GCE disk type. Such as "pd-ssd", "local-ssd",
    /// "pd-balanced" or "pd-standard", "hyperdisk-balanced", "hyperdisk-throughput" or "hyperdisk-extreme".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    #[builder(default)]
    pub disk_type: Option<String>,
    /// Specifies the disk interface to use for attaching this disk,
    /// which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
    /// and the request will fail if you attempt to attach a persistent disk in any other format
    /// than SCSI. Local SSDs can use either NVME or SCSI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub interface: Option<String>,
    /// A set of ket/value label pairs to assign to disk created from
    /// this template
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The mode in which to attach this disk, either READ_WRITE
    /// or READ_ONLY. If you are attaching or creating a boot disk, this must
    /// read-write mode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
    /// Indicates how many IOPS to provision for the disk. This
    /// sets the number of I/O operations per second that the disk can handle.
    /// Values must be between 10,000 and 120,000. For more details, see the
    /// Extreme persistent disk documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedIops")]
    #[builder(default)]
    pub provisioned_iops: Option<f64>,
    /// A set of key/value resource manager tag pairs to bind to this disk. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// - A list (short name or id) of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePolicies")]
    #[builder(default)]
    pub resource_policies: Option<Vec<String>>,
    /// The name (not self_link)
    /// of the disk (such as those managed by google_compute_disk) to attach.
    /// ~> Note: Either source, source_image, or source_snapshot is required in a disk block unless the disk type is local-ssd. Check the API docs for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<String>,
    /// The image from which to
    /// initialize this disk. This can be one of: the image's self_link,
    /// projects/{project}/global/images/{image},
    /// projects/{project}/global/images/family/{family}, global/images/{image},
    /// global/images/family/{family}, family/{family}, {project}/{family},
    /// {project}/{image}, {family}, or {image}.
    /// ~> Note: Either source, source_image, or source_snapshot is required in a disk block unless the disk type is local-ssd. Check the API docs for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceImage")]
    #[builder(default)]
    pub source_image: Option<String>,
    /// The customer-supplied encryption
    /// key of the source image. Required if the source image is protected by a
    /// customer-supplied encryption key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceImageEncryptionKey")]
    #[builder(default)]
    pub source_image_encryption_key: Option<InstanceTemplateStatusAtProviderDiskSourceImageEncryptionKey>,
    /// The source snapshot to create this disk.
    /// ~> Note: Either source, source_image, or source_snapshot is required in a disk block unless the disk type is local-ssd. Check the API docs for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSnapshot")]
    #[builder(default)]
    pub source_snapshot: Option<String>,
    /// The customer-supplied encryption
    /// key of the source snapshot. Structure
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSnapshotEncryptionKey")]
    #[builder(default)]
    pub source_snapshot_encryption_key: Option<InstanceTemplateStatusAtProviderDiskSourceSnapshotEncryptionKey>,
    /// The type of GCE disk, can be either "SCRATCH" or
    /// "PERSISTENT".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Encrypts or decrypts a disk using a customer-supplied encryption key.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderDiskDiskEncryptionKey {
    /// The self link of the encryption key that is
    /// stored in Google Cloud KMS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
}

/// The customer-supplied encryption
/// key of the source image. Required if the source image is protected by a
/// customer-supplied encryption key.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderDiskSourceImageEncryptionKey {
    /// The self link of the encryption key that is
    /// stored in Google Cloud KMS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
    /// The service account being used for the
    /// encryption request for the given KMS key. If absent, the Compute Engine
    /// default service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyServiceAccount")]
    #[builder(default)]
    pub kms_key_service_account: Option<String>,
}

/// The customer-supplied encryption
/// key of the source snapshot. Structure
/// documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderDiskSourceSnapshotEncryptionKey {
    /// The self link of the encryption key that is
    /// stored in Google Cloud KMS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
    /// The service account being used for the
    /// encryption request for the given KMS key. If absent, the Compute Engine
    /// default service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyServiceAccount")]
    #[builder(default)]
    pub kms_key_service_account: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderGuestAccelerator {
    /// The number of the guest accelerator cards exposed to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderNetworkInterface {
    /// Access configurations, i.e. IPs via which this
    /// instance can be accessed via the Internet.g. via tunnel or because it is running on another cloud instance
    /// on that network). This block can be repeated multiple times. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessConfig")]
    #[builder(default)]
    pub access_config: Option<Vec<InstanceTemplateStatusAtProviderNetworkInterfaceAccessConfig>>,
    /// An
    /// array of alias IP ranges for this network interface. Can only be specified for network
    /// interfaces on subnet-mode networks. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "aliasIpRange")]
    #[builder(default)]
    pub alias_ip_range: Option<Vec<InstanceTemplateStatusAtProviderNetworkInterfaceAliasIpRange>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIpv6PrefixLength")]
    #[builder(default)]
    pub internal_ipv6_prefix_length: Option<f64>,
    /// An array of IPv6 access configurations for this interface.
    /// Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
    /// specified, then this instance will have no external IPv6 Internet access. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AccessConfig")]
    #[builder(default)]
    pub ipv6_access_config: Option<Vec<InstanceTemplateStatusAtProviderNetworkInterfaceIpv6AccessConfig>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AccessType")]
    #[builder(default)]
    pub ipv6_access_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Address")]
    #[builder(default)]
    pub ipv6_address: Option<String>,
    /// The name of the instance template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The name or self_link of the network to attach this interface to.
    /// Use network attribute for Legacy or Auto subnetted networks and
    /// subnetwork for custom subnetted networks.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// The private IP address to assign to the instance. If
    /// empty, the address will be automatically assigned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkIp")]
    #[builder(default)]
    pub network_ip: Option<String>,
    /// The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nicType")]
    #[builder(default)]
    pub nic_type: Option<String>,
    /// The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueCount")]
    #[builder(default)]
    pub queue_count: Option<f64>,
    /// The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6 or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    #[builder(default)]
    pub stack_type: Option<String>,
    /// the name of the subnetwork to attach this interface
    /// to. The subnetwork must exist in the same region this instance will be
    /// created in. Either network or subnetwork must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// The ID of the project in which the subnetwork belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkProject")]
    #[builder(default)]
    pub subnetwork_project: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderNetworkInterfaceAccessConfig {
    /// The IP address that will be 1:1 mapped to the instance's
    /// network ip. If not given, one will be generated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natIp")]
    #[builder(default)]
    pub nat_ip: Option<String>,
    /// The service-level to be provided for IPv6 traffic when the
    /// subnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
    /// The name of the instance template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    #[builder(default)]
    pub public_ptr_domain_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderNetworkInterfaceAliasIpRange {
    /// The IP CIDR range represented by this alias IP range. This IP CIDR range
    /// must belong to the specified subnetwork and cannot contain IP addresses reserved by
    /// system or used by other network interfaces. At the time of writing only a
    /// netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
    /// error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipCidrRange")]
    #[builder(default)]
    pub ip_cidr_range: Option<String>,
    /// The subnetwork secondary range name specifying
    /// the secondary range from which to allocate the IP CIDR range for this alias IP
    /// range. If left unspecified, the primary range of the subnetwork will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRangeName")]
    #[builder(default)]
    pub subnetwork_range_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderNetworkInterfaceIpv6AccessConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6")]
    #[builder(default)]
    pub external_ipv6: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6PrefixLength")]
    #[builder(default)]
    pub external_ipv6_prefix_length: Option<String>,
    /// The name of the instance template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The service-level to be provided for IPv6 traffic when the
    /// subnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
    /// The name of the instance template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    #[builder(default)]
    pub public_ptr_domain_name: Option<String>,
}

/// os-features, and network_interface.0.nic-type must be GVNIC
/// in order for this setting to take effect.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderNetworkPerformanceConfig {
    /// The egress bandwidth tier to enable. Possible values: TIER_1, DEFAULT
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    #[builder(default)]
    pub total_egress_bandwidth_tier: Option<String>,
}

/// Specifies the reservations that this instance can consume from.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderReservationAffinity {
    /// Specifies the label selector for the reservation to use..
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "specificReservation")]
    #[builder(default)]
    pub specific_reservation: Option<InstanceTemplateStatusAtProviderReservationAffinitySpecificReservation>,
    /// The type of reservation from which this instance can consume resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Specifies the label selector for the reservation to use..
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderReservationAffinitySpecificReservation {
    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// Corresponds to the label values of a reservation resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

/// The scheduling strategy to use. More details about
/// this configuration option are detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderScheduling {
    /// Specifies whether the instance should be
    /// automatically restarted if it is terminated by Compute Engine (not
    /// terminated by a user). This defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticRestart")]
    #[builder(default)]
    pub automatic_restart: Option<bool>,
    /// Describe the type of termination action for SPOT VM. Can be STOP or DELETE.  Read more on here
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTerminationAction")]
    #[builder(default)]
    pub instance_termination_action: Option<String>,
    /// io/docs/providers/google/guides/provider_versions.html) Specifies the maximum amount of time a Local Ssd Vm should wait while recovery of the Local Ssd state is attempted. Its value should be in between 0 and 168 hours with hour granularity and the default value being 1 hour. Structure is documented below.
    /// The local_ssd_recovery_timeout block supports:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdRecoveryTimeout")]
    #[builder(default)]
    pub local_ssd_recovery_timeout: Option<Vec<InstanceTemplateStatusAtProviderSchedulingLocalSsdRecoveryTimeout>>,
    /// The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in instance_termination_action. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRunDuration")]
    #[builder(default)]
    pub max_run_duration: Option<InstanceTemplateStatusAtProviderSchedulingMaxRunDuration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCpus")]
    #[builder(default)]
    pub min_node_cpus: Option<f64>,
    /// Specifies node affinities or anti-affinities
    /// to determine which sole-tenant nodes your instances and managed instance
    /// groups will use as host systems. Read more on sole-tenant node creation
    /// here.
    /// Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinities")]
    #[builder(default)]
    pub node_affinities: Option<Vec<InstanceTemplateStatusAtProviderSchedulingNodeAffinities>>,
    /// Defines the maintenance behavior for this
    /// instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onHostMaintenance")]
    #[builder(default)]
    pub on_host_maintenance: Option<String>,
    /// Specifies the action to be performed when the instance is terminated using max_run_duration and STOP instance_termination_action. Only support true discard_local_ssd at this point. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onInstanceStopAction")]
    #[builder(default)]
    pub on_instance_stop_action: Option<InstanceTemplateStatusAtProviderSchedulingOnInstanceStopAction>,
    /// Allows instance to be preempted. This defaults to
    /// false. Read more on this
    /// here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub preemptible: Option<bool>,
    /// Describe the type of preemptible VM. This field accepts the value STANDARD or SPOT. If the value is STANDARD, there will be no discount. If this   is set to SPOT,
    /// preemptible should be true and automatic_restart should be
    /// false. For more info about
    /// SPOT, read here
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisioningModel")]
    #[builder(default)]
    pub provisioning_model: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderSchedulingLocalSsdRecoveryTimeout {
    /// Span of time that's a fraction of a second at nanosecond
    /// resolution. Durations less than one second are represented with a 0
    /// seconds field and a positive nanos field. Must be from 0 to
    /// 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to
    /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
    /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in instance_termination_action. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderSchedulingMaxRunDuration {
    /// Span of time that's a fraction of a second at nanosecond
    /// resolution. Durations less than one second are represented with a 0
    /// seconds field and a positive nanos field. Must be from 0 to
    /// 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to
    /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
    /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderSchedulingNodeAffinities {
    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// The operator. Can be IN for node-affinities
    /// or NOT_IN for anti-affinities.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Corresponds to the label values of a reservation resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

/// Specifies the action to be performed when the instance is terminated using max_run_duration and STOP instance_termination_action. Only support true discard_local_ssd at this point. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderSchedulingOnInstanceStopAction {
    /// Whether to discard local SSDs attached to the VM while terminating using max_run_duration. Only supports true at this point.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discardLocalSsd")]
    #[builder(default)]
    pub discard_local_ssd: Option<bool>,
}

/// Service account to attach to the instance. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderServiceAccount {
    /// The service account e-mail address. If not given, the
    /// default Google Compute Engine service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub email: Option<String>,
    /// A list of service scopes. Both OAuth2 URLs and gcloud
    /// short names are supported. To allow full access to all Cloud APIs, use the
    /// cloud-platform scope. See a complete list of scopes here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scopes: Option<Vec<String>>,
}

/// Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.
/// Note: shielded_instance_config can only be used with boot images with shielded vm support. See the complete list here.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceTemplateStatusAtProviderShieldedInstanceConfig {
    /// - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    #[builder(default)]
    pub enable_integrity_monitoring: Option<bool>,
    /// - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    #[builder(default)]
    pub enable_secure_boot: Option<bool>,
    /// - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableVtpm")]
    #[builder(default)]
    pub enable_vtpm: Option<bool>,
}

