// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// GlobalForwardingRuleSpec defines the desired state of GlobalForwardingRule
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta2", kind = "GlobalForwardingRule", plural = "globalforwardingrules")]
#[kube(status = "GlobalForwardingRuleStatus")]
pub struct GlobalForwardingRuleSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<GlobalForwardingRuleDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: GlobalForwardingRuleForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<GlobalForwardingRuleInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<GlobalForwardingRuleProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<GlobalForwardingRulePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<GlobalForwardingRuleWriteConnectionSecretToRef>,
}

/// GlobalForwardingRuleSpec defines the desired state of GlobalForwardingRule
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProvider {
    /// An optional description of this resource. Provide this property when
    /// you create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// IP address for which this forwarding rule accepts traffic. When a client
    /// sends traffic to this IP address, the forwarding rule directs the traffic
    /// to the referenced target.
    /// While creating a forwarding rule, specifying an IPAddress is
    /// required under the following circumstances:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default)]
    pub ip_address: Option<String>,
    /// Reference to a GlobalAddress in compute to populate ipAddress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddressRef")]
    #[builder(default)]
    pub ip_address_ref: Option<GlobalForwardingRuleForProviderIpAddressRef>,
    /// Selector for a GlobalAddress in compute to populate ipAddress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddressSelector")]
    #[builder(default)]
    pub ip_address_selector: Option<GlobalForwardingRuleForProviderIpAddressSelector>,
    /// The IP protocol to which this rule applies.
    /// For protocol forwarding, valid
    /// options are TCP, UDP, ESP,
    /// AH, SCTP, ICMP and
    /// L3_DEFAULT.
    /// The valid IP protocols are different for different load balancing products
    /// as described in Load balancing
    /// features.
    /// Possible values are: TCP, UDP, ESP, AH, SCTP, ICMP.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipProtocol")]
    #[builder(default)]
    pub ip_protocol: Option<String>,
    /// The IP Version that will be used by this global forwarding rule.
    /// Possible values are: IPV4, IPV6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipVersion")]
    #[builder(default)]
    pub ip_version: Option<String>,
    /// Labels to apply to this forwarding rule.  A list of key->value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Specifies the forwarding rule type.
    /// For more information about forwarding rules, refer to
    /// Forwarding rule concepts.
    /// Default value is EXTERNAL.
    /// Possible values are: EXTERNAL, EXTERNAL_MANAGED, INTERNAL_MANAGED, INTERNAL_SELF_MANAGED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingScheme")]
    #[builder(default)]
    pub load_balancing_scheme: Option<String>,
    /// Opaque filter criteria used by Loadbalancer to restrict routing
    /// configuration to a limited set xDS compliant clients. In their xDS
    /// requests to Loadbalancer, xDS clients present node metadata. If a
    /// match takes place, the relevant routing configuration is made available
    /// to those proxies.
    /// For each metadataFilter in this list, if its filterMatchCriteria is set
    /// to MATCH_ANY, at least one of the filterLabels must match the
    /// corresponding label provided in the metadata. If its filterMatchCriteria
    /// is set to MATCH_ALL, then all of its filterLabels must match with
    /// corresponding labels in the provided metadata.
    /// metadataFilters specified here can be overridden by those specified in
    /// the UrlMap that this ForwardingRule references.
    /// metadataFilters only applies to Loadbalancers that have their
    /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataFilters")]
    #[builder(default)]
    pub metadata_filters: Option<Vec<GlobalForwardingRuleForProviderMetadataFilters>>,
    /// This field is not used for external load balancing.
    /// For Internal TCP/UDP Load Balancing, this field identifies the network that
    /// the load balanced IP should belong to for this Forwarding Rule.
    /// If the subnetwork is specified, the network of the subnetwork will be used.
    /// If neither subnetwork nor this field is specified, the default network will
    /// be used.
    /// For Private Service Connect forwarding rules that forward traffic to Google
    /// APIs, a network must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    #[builder(default)]
    pub network_ref: Option<GlobalForwardingRuleForProviderNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    #[builder(default)]
    pub network_selector: Option<GlobalForwardingRuleForProviderNetworkSelector>,
    /// This is used in PSC consumer ForwardingRule to control whether it should try to auto-generate a DNS zone or not. Non-PSC forwarding rules do not use this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noAutomateDnsZone")]
    #[builder(default)]
    pub no_automate_dns_zone: Option<bool>,
    /// The portRange field has the following limitations:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portRange")]
    #[builder(default)]
    pub port_range: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Reference to a Network in compute to populate project.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectRef")]
    #[builder(default)]
    pub project_ref: Option<GlobalForwardingRuleForProviderProjectRef>,
    /// Selector for a Network in compute to populate project.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectSelector")]
    #[builder(default)]
    pub project_selector: Option<GlobalForwardingRuleForProviderProjectSelector>,
    /// Service Directory resources to register this forwarding rule with.
    /// Currently, only supports a single Service Directory resource.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDirectoryRegistrations")]
    #[builder(default)]
    pub service_directory_registrations: Option<GlobalForwardingRuleForProviderServiceDirectoryRegistrations>,
    /// If not empty, this Forwarding Rule will only forward the traffic when the source IP address matches one of the IP addresses or CIDR ranges set here. Note that a Forwarding Rule can only have up to 64 source IP ranges, and this field can only be used with a regional Forwarding Rule whose scheme is EXTERNAL. Each sourceIpRange entry should be either an IP address (for example, 1.2.3.4) or a CIDR range (for example, 1.2.3.0/24).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceIpRanges")]
    #[builder(default)]
    pub source_ip_ranges: Option<Vec<String>>,
    /// This field identifies the subnetwork that the load balanced IP should
    /// belong to for this Forwarding Rule, used in internal load balancing and
    /// network load balancing with IPv6.
    /// If the network specified is in auto subnet mode, this field is optional.
    /// However, a subnetwork must be specified if the network is in custom subnet
    /// mode or when creating external forwarding rule with IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    #[builder(default)]
    pub subnetwork_ref: Option<GlobalForwardingRuleForProviderSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    #[builder(default)]
    pub subnetwork_selector: Option<GlobalForwardingRuleForProviderSubnetworkSelector>,
    /// The URL of the target resource to receive the matched traffic.  For
    /// regional forwarding rules, this target must be in the same region as the
    /// forwarding rule. For global forwarding rules, this target must be a global
    /// load balancing resource.
    /// The forwarded traffic must be of a type appropriate to the target object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub target: Option<String>,
    /// Reference to a TargetSSLProxy in compute to populate target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetRef")]
    #[builder(default)]
    pub target_ref: Option<GlobalForwardingRuleForProviderTargetRef>,
    /// Selector for a TargetSSLProxy in compute to populate target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSelector")]
    #[builder(default)]
    pub target_selector: Option<GlobalForwardingRuleForProviderTargetSelector>,
}

/// Reference to a GlobalAddress in compute to populate ipAddress.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderIpAddressRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleForProviderIpAddressRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderIpAddressRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleForProviderIpAddressRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleForProviderIpAddressRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderIpAddressRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderIpAddressRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a GlobalAddress in compute to populate ipAddress.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderIpAddressSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleForProviderIpAddressSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderIpAddressSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleForProviderIpAddressSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleForProviderIpAddressSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderIpAddressSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderIpAddressSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderMetadataFilters {
    /// The list of label value pairs that must match labels in the
    /// provided metadata based on filterMatchCriteria
    /// This list must not be empty and can have at the most 64 entries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterLabels")]
    #[builder(default)]
    pub filter_labels: Option<Vec<GlobalForwardingRuleForProviderMetadataFiltersFilterLabels>>,
    /// Specifies how individual filterLabel matches within the list of
    /// filterLabels contribute towards the overall metadataFilter match.
    /// MATCH_ANY - At least one of the filterLabels must have a matching
    /// label in the provided metadata.
    /// MATCH_ALL - All filterLabels must have matching labels in the
    /// provided metadata.
    /// Possible values are: MATCH_ANY, MATCH_ALL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterMatchCriteria")]
    #[builder(default)]
    pub filter_match_criteria: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderMetadataFiltersFilterLabels {
    /// Name of the resource; provided by the client when the resource is created.
    /// The name must be 1-63 characters long, and comply with
    /// RFC1035.
    /// Specifically, the name must be 1-63 characters long and match the regular
    /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first
    /// character must be a lowercase letter, and all following characters must
    /// be a dash, lowercase letter, or digit, except the last character, which
    /// cannot be a dash.
    /// For Private Service Connect forwarding rules that forward traffic to Google
    /// APIs, the forwarding rule name must be a 1-20 characters string with
    /// lowercase letters and numbers and must start with a letter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The value that the label must match. The value has a maximum
    /// length of 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleForProviderNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleForProviderNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleForProviderNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleForProviderNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleForProviderNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleForProviderNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Network in compute to populate project.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderProjectRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleForProviderProjectRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderProjectRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleForProviderProjectRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleForProviderProjectRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderProjectRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderProjectRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate project.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderProjectSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleForProviderProjectSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderProjectSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleForProviderProjectSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleForProviderProjectSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderProjectSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderProjectSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Service Directory resources to register this forwarding rule with.
/// Currently, only supports a single Service Directory resource.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderServiceDirectoryRegistrations {
    /// Service Directory namespace to register the forwarding rule under.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespace: Option<String>,
    /// [Optional] Service Directory region to register this global forwarding rule under.
    /// Default to "us-central1". Only used for PSC for Google APIs. All PSC for
    /// Google APIs Forwarding Rules on the same network should use the same Service
    /// Directory region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDirectoryRegion")]
    #[builder(default)]
    pub service_directory_region: Option<String>,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleForProviderSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleForProviderSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleForProviderSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleForProviderSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleForProviderSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleForProviderSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a TargetSSLProxy in compute to populate target.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderTargetRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleForProviderTargetRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderTargetRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleForProviderTargetRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleForProviderTargetRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderTargetRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderTargetRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a TargetSSLProxy in compute to populate target.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderTargetSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleForProviderTargetSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleForProviderTargetSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleForProviderTargetSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleForProviderTargetSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderTargetSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleForProviderTargetSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProvider {
    /// An optional description of this resource. Provide this property when
    /// you create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// IP address for which this forwarding rule accepts traffic. When a client
    /// sends traffic to this IP address, the forwarding rule directs the traffic
    /// to the referenced target.
    /// While creating a forwarding rule, specifying an IPAddress is
    /// required under the following circumstances:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default)]
    pub ip_address: Option<String>,
    /// Reference to a GlobalAddress in compute to populate ipAddress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddressRef")]
    #[builder(default)]
    pub ip_address_ref: Option<GlobalForwardingRuleInitProviderIpAddressRef>,
    /// Selector for a GlobalAddress in compute to populate ipAddress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddressSelector")]
    #[builder(default)]
    pub ip_address_selector: Option<GlobalForwardingRuleInitProviderIpAddressSelector>,
    /// The IP protocol to which this rule applies.
    /// For protocol forwarding, valid
    /// options are TCP, UDP, ESP,
    /// AH, SCTP, ICMP and
    /// L3_DEFAULT.
    /// The valid IP protocols are different for different load balancing products
    /// as described in Load balancing
    /// features.
    /// Possible values are: TCP, UDP, ESP, AH, SCTP, ICMP.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipProtocol")]
    #[builder(default)]
    pub ip_protocol: Option<String>,
    /// The IP Version that will be used by this global forwarding rule.
    /// Possible values are: IPV4, IPV6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipVersion")]
    #[builder(default)]
    pub ip_version: Option<String>,
    /// Labels to apply to this forwarding rule.  A list of key->value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Specifies the forwarding rule type.
    /// For more information about forwarding rules, refer to
    /// Forwarding rule concepts.
    /// Default value is EXTERNAL.
    /// Possible values are: EXTERNAL, EXTERNAL_MANAGED, INTERNAL_MANAGED, INTERNAL_SELF_MANAGED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingScheme")]
    #[builder(default)]
    pub load_balancing_scheme: Option<String>,
    /// Opaque filter criteria used by Loadbalancer to restrict routing
    /// configuration to a limited set xDS compliant clients. In their xDS
    /// requests to Loadbalancer, xDS clients present node metadata. If a
    /// match takes place, the relevant routing configuration is made available
    /// to those proxies.
    /// For each metadataFilter in this list, if its filterMatchCriteria is set
    /// to MATCH_ANY, at least one of the filterLabels must match the
    /// corresponding label provided in the metadata. If its filterMatchCriteria
    /// is set to MATCH_ALL, then all of its filterLabels must match with
    /// corresponding labels in the provided metadata.
    /// metadataFilters specified here can be overridden by those specified in
    /// the UrlMap that this ForwardingRule references.
    /// metadataFilters only applies to Loadbalancers that have their
    /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataFilters")]
    #[builder(default)]
    pub metadata_filters: Option<Vec<GlobalForwardingRuleInitProviderMetadataFilters>>,
    /// This field is not used for external load balancing.
    /// For Internal TCP/UDP Load Balancing, this field identifies the network that
    /// the load balanced IP should belong to for this Forwarding Rule.
    /// If the subnetwork is specified, the network of the subnetwork will be used.
    /// If neither subnetwork nor this field is specified, the default network will
    /// be used.
    /// For Private Service Connect forwarding rules that forward traffic to Google
    /// APIs, a network must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    #[builder(default)]
    pub network_ref: Option<GlobalForwardingRuleInitProviderNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    #[builder(default)]
    pub network_selector: Option<GlobalForwardingRuleInitProviderNetworkSelector>,
    /// This is used in PSC consumer ForwardingRule to control whether it should try to auto-generate a DNS zone or not. Non-PSC forwarding rules do not use this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noAutomateDnsZone")]
    #[builder(default)]
    pub no_automate_dns_zone: Option<bool>,
    /// The portRange field has the following limitations:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portRange")]
    #[builder(default)]
    pub port_range: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Reference to a Network in compute to populate project.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectRef")]
    #[builder(default)]
    pub project_ref: Option<GlobalForwardingRuleInitProviderProjectRef>,
    /// Selector for a Network in compute to populate project.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectSelector")]
    #[builder(default)]
    pub project_selector: Option<GlobalForwardingRuleInitProviderProjectSelector>,
    /// Service Directory resources to register this forwarding rule with.
    /// Currently, only supports a single Service Directory resource.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDirectoryRegistrations")]
    #[builder(default)]
    pub service_directory_registrations: Option<GlobalForwardingRuleInitProviderServiceDirectoryRegistrations>,
    /// If not empty, this Forwarding Rule will only forward the traffic when the source IP address matches one of the IP addresses or CIDR ranges set here. Note that a Forwarding Rule can only have up to 64 source IP ranges, and this field can only be used with a regional Forwarding Rule whose scheme is EXTERNAL. Each sourceIpRange entry should be either an IP address (for example, 1.2.3.4) or a CIDR range (for example, 1.2.3.0/24).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceIpRanges")]
    #[builder(default)]
    pub source_ip_ranges: Option<Vec<String>>,
    /// This field identifies the subnetwork that the load balanced IP should
    /// belong to for this Forwarding Rule, used in internal load balancing and
    /// network load balancing with IPv6.
    /// If the network specified is in auto subnet mode, this field is optional.
    /// However, a subnetwork must be specified if the network is in custom subnet
    /// mode or when creating external forwarding rule with IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    #[builder(default)]
    pub subnetwork_ref: Option<GlobalForwardingRuleInitProviderSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    #[builder(default)]
    pub subnetwork_selector: Option<GlobalForwardingRuleInitProviderSubnetworkSelector>,
    /// The URL of the target resource to receive the matched traffic.  For
    /// regional forwarding rules, this target must be in the same region as the
    /// forwarding rule. For global forwarding rules, this target must be a global
    /// load balancing resource.
    /// The forwarded traffic must be of a type appropriate to the target object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub target: Option<String>,
    /// Reference to a TargetSSLProxy in compute to populate target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetRef")]
    #[builder(default)]
    pub target_ref: Option<GlobalForwardingRuleInitProviderTargetRef>,
    /// Selector for a TargetSSLProxy in compute to populate target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSelector")]
    #[builder(default)]
    pub target_selector: Option<GlobalForwardingRuleInitProviderTargetSelector>,
}

/// Reference to a GlobalAddress in compute to populate ipAddress.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderIpAddressRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleInitProviderIpAddressRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderIpAddressRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleInitProviderIpAddressRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleInitProviderIpAddressRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderIpAddressRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderIpAddressRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a GlobalAddress in compute to populate ipAddress.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderIpAddressSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleInitProviderIpAddressSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderIpAddressSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleInitProviderIpAddressSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleInitProviderIpAddressSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderIpAddressSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderIpAddressSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderMetadataFilters {
    /// The list of label value pairs that must match labels in the
    /// provided metadata based on filterMatchCriteria
    /// This list must not be empty and can have at the most 64 entries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterLabels")]
    #[builder(default)]
    pub filter_labels: Option<Vec<GlobalForwardingRuleInitProviderMetadataFiltersFilterLabels>>,
    /// Specifies how individual filterLabel matches within the list of
    /// filterLabels contribute towards the overall metadataFilter match.
    /// MATCH_ANY - At least one of the filterLabels must have a matching
    /// label in the provided metadata.
    /// MATCH_ALL - All filterLabels must have matching labels in the
    /// provided metadata.
    /// Possible values are: MATCH_ANY, MATCH_ALL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterMatchCriteria")]
    #[builder(default)]
    pub filter_match_criteria: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderMetadataFiltersFilterLabels {
    /// Name of the resource; provided by the client when the resource is created.
    /// The name must be 1-63 characters long, and comply with
    /// RFC1035.
    /// Specifically, the name must be 1-63 characters long and match the regular
    /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first
    /// character must be a lowercase letter, and all following characters must
    /// be a dash, lowercase letter, or digit, except the last character, which
    /// cannot be a dash.
    /// For Private Service Connect forwarding rules that forward traffic to Google
    /// APIs, the forwarding rule name must be a 1-20 characters string with
    /// lowercase letters and numbers and must start with a letter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The value that the label must match. The value has a maximum
    /// length of 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleInitProviderNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleInitProviderNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleInitProviderNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleInitProviderNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleInitProviderNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleInitProviderNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Network in compute to populate project.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderProjectRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleInitProviderProjectRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderProjectRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleInitProviderProjectRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleInitProviderProjectRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderProjectRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderProjectRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate project.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderProjectSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleInitProviderProjectSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderProjectSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleInitProviderProjectSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleInitProviderProjectSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderProjectSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderProjectSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Service Directory resources to register this forwarding rule with.
/// Currently, only supports a single Service Directory resource.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderServiceDirectoryRegistrations {
    /// Service Directory namespace to register the forwarding rule under.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespace: Option<String>,
    /// [Optional] Service Directory region to register this global forwarding rule under.
    /// Default to "us-central1". Only used for PSC for Google APIs. All PSC for
    /// Google APIs Forwarding Rules on the same network should use the same Service
    /// Directory region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDirectoryRegion")]
    #[builder(default)]
    pub service_directory_region: Option<String>,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleInitProviderSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleInitProviderSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleInitProviderSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleInitProviderSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleInitProviderSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleInitProviderSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a TargetSSLProxy in compute to populate target.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderTargetRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleInitProviderTargetRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderTargetRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleInitProviderTargetRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleInitProviderTargetRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderTargetRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderTargetRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a TargetSSLProxy in compute to populate target.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderTargetSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleInitProviderTargetSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleInitProviderTargetSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleInitProviderTargetSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleInitProviderTargetSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderTargetSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleInitProviderTargetSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRuleProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRuleProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRuleProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRuleProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRulePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<GlobalForwardingRulePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<GlobalForwardingRulePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRulePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<GlobalForwardingRulePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRulePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<GlobalForwardingRulePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<GlobalForwardingRulePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRulePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GlobalForwardingRulePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRulePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// GlobalForwardingRuleStatus defines the observed state of GlobalForwardingRule.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<GlobalForwardingRuleStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleStatusAtProvider {
    /// [Output Only] The URL for the corresponding base Forwarding Rule. By base Forwarding Rule, we mean the Forwarding Rule that has the same IP address, protocol, and port settings with the current Forwarding Rule, but without sourceIPRanges specified. Always empty if the current Forwarding Rule does not have sourceIPRanges specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseForwardingRule")]
    #[builder(default)]
    pub base_forwarding_rule: Option<String>,
    /// An optional description of this resource. Provide this property when
    /// you create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveLabels")]
    #[builder(default)]
    pub effective_labels: Option<HashMap<String, String>>,
    /// an identifier for the resource with format projects/{{project}}/global/forwardingRules/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// IP address for which this forwarding rule accepts traffic. When a client
    /// sends traffic to this IP address, the forwarding rule directs the traffic
    /// to the referenced target.
    /// While creating a forwarding rule, specifying an IPAddress is
    /// required under the following circumstances:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default)]
    pub ip_address: Option<String>,
    /// The IP protocol to which this rule applies.
    /// For protocol forwarding, valid
    /// options are TCP, UDP, ESP,
    /// AH, SCTP, ICMP and
    /// L3_DEFAULT.
    /// The valid IP protocols are different for different load balancing products
    /// as described in Load balancing
    /// features.
    /// Possible values are: TCP, UDP, ESP, AH, SCTP, ICMP.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipProtocol")]
    #[builder(default)]
    pub ip_protocol: Option<String>,
    /// The IP Version that will be used by this global forwarding rule.
    /// Possible values are: IPV4, IPV6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipVersion")]
    #[builder(default)]
    pub ip_version: Option<String>,
    /// The fingerprint used for optimistic locking of this resource.  Used
    /// internally during updates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelFingerprint")]
    #[builder(default)]
    pub label_fingerprint: Option<String>,
    /// Labels to apply to this forwarding rule.  A list of key->value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Specifies the forwarding rule type.
    /// For more information about forwarding rules, refer to
    /// Forwarding rule concepts.
    /// Default value is EXTERNAL.
    /// Possible values are: EXTERNAL, EXTERNAL_MANAGED, INTERNAL_MANAGED, INTERNAL_SELF_MANAGED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingScheme")]
    #[builder(default)]
    pub load_balancing_scheme: Option<String>,
    /// Opaque filter criteria used by Loadbalancer to restrict routing
    /// configuration to a limited set xDS compliant clients. In their xDS
    /// requests to Loadbalancer, xDS clients present node metadata. If a
    /// match takes place, the relevant routing configuration is made available
    /// to those proxies.
    /// For each metadataFilter in this list, if its filterMatchCriteria is set
    /// to MATCH_ANY, at least one of the filterLabels must match the
    /// corresponding label provided in the metadata. If its filterMatchCriteria
    /// is set to MATCH_ALL, then all of its filterLabels must match with
    /// corresponding labels in the provided metadata.
    /// metadataFilters specified here can be overridden by those specified in
    /// the UrlMap that this ForwardingRule references.
    /// metadataFilters only applies to Loadbalancers that have their
    /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataFilters")]
    #[builder(default)]
    pub metadata_filters: Option<Vec<GlobalForwardingRuleStatusAtProviderMetadataFilters>>,
    /// This field is not used for external load balancing.
    /// For Internal TCP/UDP Load Balancing, this field identifies the network that
    /// the load balanced IP should belong to for this Forwarding Rule.
    /// If the subnetwork is specified, the network of the subnetwork will be used.
    /// If neither subnetwork nor this field is specified, the default network will
    /// be used.
    /// For Private Service Connect forwarding rules that forward traffic to Google
    /// APIs, a network must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// This is used in PSC consumer ForwardingRule to control whether it should try to auto-generate a DNS zone or not. Non-PSC forwarding rules do not use this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noAutomateDnsZone")]
    #[builder(default)]
    pub no_automate_dns_zone: Option<bool>,
    /// The portRange field has the following limitations:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portRange")]
    #[builder(default)]
    pub port_range: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The PSC connection id of the PSC Forwarding Rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pscConnectionId")]
    #[builder(default)]
    pub psc_connection_id: Option<String>,
    /// The PSC connection status of the PSC Forwarding Rule. Possible values: STATUS_UNSPECIFIED, PENDING, ACCEPTED, REJECTED, CLOSED
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pscConnectionStatus")]
    #[builder(default)]
    pub psc_connection_status: Option<String>,
    /// The URI of the created resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLink")]
    #[builder(default)]
    pub self_link: Option<String>,
    /// Service Directory resources to register this forwarding rule with.
    /// Currently, only supports a single Service Directory resource.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDirectoryRegistrations")]
    #[builder(default)]
    pub service_directory_registrations: Option<GlobalForwardingRuleStatusAtProviderServiceDirectoryRegistrations>,
    /// If not empty, this Forwarding Rule will only forward the traffic when the source IP address matches one of the IP addresses or CIDR ranges set here. Note that a Forwarding Rule can only have up to 64 source IP ranges, and this field can only be used with a regional Forwarding Rule whose scheme is EXTERNAL. Each sourceIpRange entry should be either an IP address (for example, 1.2.3.4) or a CIDR range (for example, 1.2.3.0/24).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceIpRanges")]
    #[builder(default)]
    pub source_ip_ranges: Option<Vec<String>>,
    /// This field identifies the subnetwork that the load balanced IP should
    /// belong to for this Forwarding Rule, used in internal load balancing and
    /// network load balancing with IPv6.
    /// If the network specified is in auto subnet mode, this field is optional.
    /// However, a subnetwork must be specified if the network is in custom subnet
    /// mode or when creating external forwarding rule with IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// The URL of the target resource to receive the matched traffic.  For
    /// regional forwarding rules, this target must be in the same region as the
    /// forwarding rule. For global forwarding rules, this target must be a global
    /// load balancing resource.
    /// The forwarded traffic must be of a type appropriate to the target object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub target: Option<String>,
    /// The combination of labels configured directly on the resource
    /// and default labels configured on the provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terraformLabels")]
    #[builder(default)]
    pub terraform_labels: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleStatusAtProviderMetadataFilters {
    /// The list of label value pairs that must match labels in the
    /// provided metadata based on filterMatchCriteria
    /// This list must not be empty and can have at the most 64 entries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterLabels")]
    #[builder(default)]
    pub filter_labels: Option<Vec<GlobalForwardingRuleStatusAtProviderMetadataFiltersFilterLabels>>,
    /// Specifies how individual filterLabel matches within the list of
    /// filterLabels contribute towards the overall metadataFilter match.
    /// MATCH_ANY - At least one of the filterLabels must have a matching
    /// label in the provided metadata.
    /// MATCH_ALL - All filterLabels must have matching labels in the
    /// provided metadata.
    /// Possible values are: MATCH_ANY, MATCH_ALL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterMatchCriteria")]
    #[builder(default)]
    pub filter_match_criteria: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleStatusAtProviderMetadataFiltersFilterLabels {
    /// Name of the resource; provided by the client when the resource is created.
    /// The name must be 1-63 characters long, and comply with
    /// RFC1035.
    /// Specifically, the name must be 1-63 characters long and match the regular
    /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first
    /// character must be a lowercase letter, and all following characters must
    /// be a dash, lowercase letter, or digit, except the last character, which
    /// cannot be a dash.
    /// For Private Service Connect forwarding rules that forward traffic to Google
    /// APIs, the forwarding rule name must be a 1-20 characters string with
    /// lowercase letters and numbers and must start with a letter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The value that the label must match. The value has a maximum
    /// length of 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

/// Service Directory resources to register this forwarding rule with.
/// Currently, only supports a single Service Directory resource.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct GlobalForwardingRuleStatusAtProviderServiceDirectoryRegistrations {
    /// Service Directory namespace to register the forwarding rule under.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespace: Option<String>,
    /// [Optional] Service Directory region to register this global forwarding rule under.
    /// Default to "us-central1". Only used for PSC for Google APIs. All PSC for
    /// Google APIs Forwarding Rules on the same network should use the same Service
    /// Directory region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDirectoryRegion")]
    #[builder(default)]
    pub service_directory_region: Option<String>,
}

