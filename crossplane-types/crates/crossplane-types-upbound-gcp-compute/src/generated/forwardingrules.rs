// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ForwardingRuleSpec defines the desired state of ForwardingRule
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta2", kind = "ForwardingRule", plural = "forwardingrules")]
#[kube(status = "ForwardingRuleStatus")]
pub struct ForwardingRuleSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<ForwardingRuleDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ForwardingRuleForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<ForwardingRuleInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<ForwardingRuleProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<ForwardingRulePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<ForwardingRuleWriteConnectionSecretToRef>,
}

/// ForwardingRuleSpec defines the desired state of ForwardingRule
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProvider {
    /// The ports, portRange, and allPorts fields are mutually exclusive.
    /// Only packets addressed to ports in the specified range will be forwarded
    /// to the backends configured with this forwarding rule.
    /// The allPorts field has the following limitations:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allPorts")]
    #[builder(default)]
    pub all_ports: Option<bool>,
    /// This field is used along with the backend_service field for
    /// internal load balancing or with the target field for internal
    /// TargetInstance.
    /// If the field is set to TRUE, clients can access ILB from all
    /// regions.
    /// Otherwise only allows access from clients in the same region as the
    /// internal load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowGlobalAccess")]
    #[builder(default)]
    pub allow_global_access: Option<bool>,
    /// This is used in PSC consumer ForwardingRule to control whether the PSC endpoint can be accessed from another region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPscGlobalAccess")]
    #[builder(default)]
    pub allow_psc_global_access: Option<bool>,
    /// Identifies the backend service to which the forwarding rule sends traffic.
    /// Required for Internal TCP/UDP Load Balancing and Network Load Balancing;
    /// must be omitted for all other load balancer types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<ForwardingRuleForProviderBackendServiceRef>,
    /// Selector for a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<ForwardingRuleForProviderBackendServiceSelector>,
    /// An optional description of this resource. Provide this property when
    /// you create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// IP address for which this forwarding rule accepts traffic. When a client
    /// sends traffic to this IP address, the forwarding rule directs the traffic
    /// to the referenced target or backendService.
    /// While creating a forwarding rule, specifying an IPAddress is
    /// required under the following circumstances:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default)]
    pub ip_address: Option<String>,
    /// Reference to a Address in compute to populate ipAddress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddressRef")]
    #[builder(default)]
    pub ip_address_ref: Option<ForwardingRuleForProviderIpAddressRef>,
    /// Selector for a Address in compute to populate ipAddress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddressSelector")]
    #[builder(default)]
    pub ip_address_selector: Option<ForwardingRuleForProviderIpAddressSelector>,
    /// The IP protocol to which this rule applies.
    /// For protocol forwarding, valid
    /// options are TCP, UDP, ESP,
    /// AH, SCTP, ICMP and
    /// L3_DEFAULT.
    /// The valid IP protocols are different for different load balancing products
    /// as described in Load balancing
    /// features.
    /// A Forwarding Rule with protocol L3_DEFAULT can attach with target instance or
    /// backend service with UNSPECIFIED protocol.
    /// A forwarding rule with "L3_DEFAULT" IPProtocal cannot be attached to a backend service with TCP or UDP.
    /// Possible values are: TCP, UDP, ESP, AH, SCTP, ICMP, L3_DEFAULT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipProtocol")]
    #[builder(default)]
    pub ip_protocol: Option<String>,
    /// The IP address version that will be used by this forwarding rule.
    /// Valid options are IPV4 and IPV6.
    /// If not set, the IPv4 address will be used by default.
    /// Possible values are: IPV4, IPV6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipVersion")]
    #[builder(default)]
    pub ip_version: Option<String>,
    /// Indicates whether or not this load balancer can be used as a collector for
    /// packet mirroring. To prevent mirroring loops, instances behind this
    /// load balancer will not have their traffic mirrored even if a
    /// PacketMirroring rule applies to them.
    /// This can only be set to true for load balancers that have their
    /// loadBalancingScheme set to INTERNAL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isMirroringCollector")]
    #[builder(default)]
    pub is_mirroring_collector: Option<bool>,
    /// Labels to apply to this forwarding rule.  A list of key->value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Specifies the forwarding rule type.
    /// For more information about forwarding rules, refer to
    /// Forwarding rule concepts.
    /// Default value is EXTERNAL.
    /// Possible values are: EXTERNAL, EXTERNAL_MANAGED, INTERNAL, INTERNAL_MANAGED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingScheme")]
    #[builder(default)]
    pub load_balancing_scheme: Option<String>,
    /// This field is not used for external load balancing.
    /// For Internal TCP/UDP Load Balancing, this field identifies the network that
    /// the load balanced IP should belong to for this Forwarding Rule.
    /// If the subnetwork is specified, the network of the subnetwork will be used.
    /// If neither subnetwork nor this field is specified, the default network will
    /// be used.
    /// For Private Service Connect forwarding rules that forward traffic to Google
    /// APIs, a network must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    #[builder(default)]
    pub network_ref: Option<ForwardingRuleForProviderNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    #[builder(default)]
    pub network_selector: Option<ForwardingRuleForProviderNetworkSelector>,
    /// This signifies the networking tier used for configuring
    /// this load balancer and can only take the following values:
    /// PREMIUM, STANDARD.
    /// For regional ForwardingRule, the valid values are PREMIUM and
    /// STANDARD. For GlobalForwardingRule, the valid value is
    /// PREMIUM.
    /// If this field is not specified, it is assumed to be PREMIUM.
    /// If IPAddress is specified, this value must be equal to the
    /// networkTier of the Address.
    /// Possible values are: PREMIUM, STANDARD.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
    /// This is used in PSC consumer ForwardingRule to control whether it should try to auto-generate a DNS zone or not. Non-PSC forwarding rules do not use this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noAutomateDnsZone")]
    #[builder(default)]
    pub no_automate_dns_zone: Option<bool>,
    /// The ports, portRange, and allPorts fields are mutually exclusive.
    /// Only packets addressed to ports in the specified range will be forwarded
    /// to the backends configured with this forwarding rule.
    /// The portRange field has the following limitations:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portRange")]
    #[builder(default)]
    pub port_range: Option<String>,
    /// The ports, portRange, and allPorts fields are mutually exclusive.
    /// Only packets addressed to ports in the specified range will be forwarded
    /// to the backends configured with this forwarding rule.
    /// The ports field has the following limitations:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ports: Option<Vec<String>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// this is used in psc consumer forwardingrule to make provider recreate the forwardingrule when the status is closed
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recreateClosedPsc")]
    #[builder(default)]
    pub recreate_closed_psc: Option<bool>,
    /// A reference to the region where the regional forwarding rule resides.
    /// This field is not applicable to global forwarding rules.
    pub region: String,
    /// Service Directory resources to register this forwarding rule with.
    /// Currently, only supports a single Service Directory resource.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDirectoryRegistrations")]
    #[builder(default)]
    pub service_directory_registrations: Option<ForwardingRuleForProviderServiceDirectoryRegistrations>,
    /// An optional prefix to the service name for this Forwarding Rule.
    /// If specified, will be the first label of the fully qualified service
    /// name.
    /// The label must be 1-63 characters long, and comply with RFC1035.
    /// Specifically, the label must be 1-63 characters long and match the
    /// regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first
    /// character must be a lowercase letter, and all following characters
    /// must be a dash, lowercase letter, or digit, except the last
    /// character, which cannot be a dash.
    /// This field is only used for INTERNAL load balancing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceLabel")]
    #[builder(default)]
    pub service_label: Option<String>,
    /// If not empty, this Forwarding Rule will only forward the traffic when the source IP address matches one of the IP addresses or CIDR ranges set here. Note that a Forwarding Rule can only have up to 64 source IP ranges, and this field can only be used with a regional Forwarding Rule whose scheme is EXTERNAL. Each sourceIpRange entry should be either an IP address (for example, 1.2.3.4) or a CIDR range (for example, 1.2.3.0/24).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceIpRanges")]
    #[builder(default)]
    pub source_ip_ranges: Option<Vec<String>>,
    /// This field identifies the subnetwork that the load balanced IP should
    /// belong to for this Forwarding Rule, used in internal load balancing and
    /// network load balancing with IPv6.
    /// If the network specified is in auto subnet mode, this field is optional.
    /// However, a subnetwork must be specified if the network is in custom subnet
    /// mode or when creating external forwarding rule with IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    #[builder(default)]
    pub subnetwork_ref: Option<ForwardingRuleForProviderSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    #[builder(default)]
    pub subnetwork_selector: Option<ForwardingRuleForProviderSubnetworkSelector>,
    /// is set to targetGrpcProxy and
    /// validateForProxyless is set to true, the
    /// IPAddress should be set to 0.0.0.0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub target: Option<String>,
    /// Reference to a RegionTargetHTTPProxy in compute to populate target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetRef")]
    #[builder(default)]
    pub target_ref: Option<ForwardingRuleForProviderTargetRef>,
    /// Selector for a RegionTargetHTTPProxy in compute to populate target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSelector")]
    #[builder(default)]
    pub target_selector: Option<ForwardingRuleForProviderTargetSelector>,
}

/// Reference to a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleForProviderBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleForProviderBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleForProviderBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleForProviderBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleForProviderBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleForProviderBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Address in compute to populate ipAddress.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderIpAddressRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleForProviderIpAddressRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderIpAddressRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleForProviderIpAddressRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleForProviderIpAddressRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderIpAddressRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderIpAddressRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Address in compute to populate ipAddress.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderIpAddressSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleForProviderIpAddressSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderIpAddressSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleForProviderIpAddressSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleForProviderIpAddressSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderIpAddressSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderIpAddressSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleForProviderNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleForProviderNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleForProviderNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleForProviderNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleForProviderNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleForProviderNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Service Directory resources to register this forwarding rule with.
/// Currently, only supports a single Service Directory resource.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderServiceDirectoryRegistrations {
    /// Service Directory namespace to register the forwarding rule under.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespace: Option<String>,
    /// Service Directory service to register the forwarding rule under.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleForProviderSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleForProviderSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleForProviderSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleForProviderSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleForProviderSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleForProviderSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a RegionTargetHTTPProxy in compute to populate target.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderTargetRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleForProviderTargetRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderTargetRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleForProviderTargetRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleForProviderTargetRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderTargetRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderTargetRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionTargetHTTPProxy in compute to populate target.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderTargetSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleForProviderTargetSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleForProviderTargetSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleForProviderTargetSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleForProviderTargetSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderTargetSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleForProviderTargetSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProvider {
    /// The ports, portRange, and allPorts fields are mutually exclusive.
    /// Only packets addressed to ports in the specified range will be forwarded
    /// to the backends configured with this forwarding rule.
    /// The allPorts field has the following limitations:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allPorts")]
    #[builder(default)]
    pub all_ports: Option<bool>,
    /// This field is used along with the backend_service field for
    /// internal load balancing or with the target field for internal
    /// TargetInstance.
    /// If the field is set to TRUE, clients can access ILB from all
    /// regions.
    /// Otherwise only allows access from clients in the same region as the
    /// internal load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowGlobalAccess")]
    #[builder(default)]
    pub allow_global_access: Option<bool>,
    /// This is used in PSC consumer ForwardingRule to control whether the PSC endpoint can be accessed from another region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPscGlobalAccess")]
    #[builder(default)]
    pub allow_psc_global_access: Option<bool>,
    /// Identifies the backend service to which the forwarding rule sends traffic.
    /// Required for Internal TCP/UDP Load Balancing and Network Load Balancing;
    /// must be omitted for all other load balancer types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<ForwardingRuleInitProviderBackendServiceRef>,
    /// Selector for a RegionBackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<ForwardingRuleInitProviderBackendServiceSelector>,
    /// An optional description of this resource. Provide this property when
    /// you create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// IP address for which this forwarding rule accepts traffic. When a client
    /// sends traffic to this IP address, the forwarding rule directs the traffic
    /// to the referenced target or backendService.
    /// While creating a forwarding rule, specifying an IPAddress is
    /// required under the following circumstances:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default)]
    pub ip_address: Option<String>,
    /// Reference to a Address in compute to populate ipAddress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddressRef")]
    #[builder(default)]
    pub ip_address_ref: Option<ForwardingRuleInitProviderIpAddressRef>,
    /// Selector for a Address in compute to populate ipAddress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddressSelector")]
    #[builder(default)]
    pub ip_address_selector: Option<ForwardingRuleInitProviderIpAddressSelector>,
    /// The IP protocol to which this rule applies.
    /// For protocol forwarding, valid
    /// options are TCP, UDP, ESP,
    /// AH, SCTP, ICMP and
    /// L3_DEFAULT.
    /// The valid IP protocols are different for different load balancing products
    /// as described in Load balancing
    /// features.
    /// A Forwarding Rule with protocol L3_DEFAULT can attach with target instance or
    /// backend service with UNSPECIFIED protocol.
    /// A forwarding rule with "L3_DEFAULT" IPProtocal cannot be attached to a backend service with TCP or UDP.
    /// Possible values are: TCP, UDP, ESP, AH, SCTP, ICMP, L3_DEFAULT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipProtocol")]
    #[builder(default)]
    pub ip_protocol: Option<String>,
    /// The IP address version that will be used by this forwarding rule.
    /// Valid options are IPV4 and IPV6.
    /// If not set, the IPv4 address will be used by default.
    /// Possible values are: IPV4, IPV6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipVersion")]
    #[builder(default)]
    pub ip_version: Option<String>,
    /// Indicates whether or not this load balancer can be used as a collector for
    /// packet mirroring. To prevent mirroring loops, instances behind this
    /// load balancer will not have their traffic mirrored even if a
    /// PacketMirroring rule applies to them.
    /// This can only be set to true for load balancers that have their
    /// loadBalancingScheme set to INTERNAL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isMirroringCollector")]
    #[builder(default)]
    pub is_mirroring_collector: Option<bool>,
    /// Labels to apply to this forwarding rule.  A list of key->value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Specifies the forwarding rule type.
    /// For more information about forwarding rules, refer to
    /// Forwarding rule concepts.
    /// Default value is EXTERNAL.
    /// Possible values are: EXTERNAL, EXTERNAL_MANAGED, INTERNAL, INTERNAL_MANAGED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingScheme")]
    #[builder(default)]
    pub load_balancing_scheme: Option<String>,
    /// This field is not used for external load balancing.
    /// For Internal TCP/UDP Load Balancing, this field identifies the network that
    /// the load balanced IP should belong to for this Forwarding Rule.
    /// If the subnetwork is specified, the network of the subnetwork will be used.
    /// If neither subnetwork nor this field is specified, the default network will
    /// be used.
    /// For Private Service Connect forwarding rules that forward traffic to Google
    /// APIs, a network must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    #[builder(default)]
    pub network_ref: Option<ForwardingRuleInitProviderNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    #[builder(default)]
    pub network_selector: Option<ForwardingRuleInitProviderNetworkSelector>,
    /// This signifies the networking tier used for configuring
    /// this load balancer and can only take the following values:
    /// PREMIUM, STANDARD.
    /// For regional ForwardingRule, the valid values are PREMIUM and
    /// STANDARD. For GlobalForwardingRule, the valid value is
    /// PREMIUM.
    /// If this field is not specified, it is assumed to be PREMIUM.
    /// If IPAddress is specified, this value must be equal to the
    /// networkTier of the Address.
    /// Possible values are: PREMIUM, STANDARD.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
    /// This is used in PSC consumer ForwardingRule to control whether it should try to auto-generate a DNS zone or not. Non-PSC forwarding rules do not use this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noAutomateDnsZone")]
    #[builder(default)]
    pub no_automate_dns_zone: Option<bool>,
    /// The ports, portRange, and allPorts fields are mutually exclusive.
    /// Only packets addressed to ports in the specified range will be forwarded
    /// to the backends configured with this forwarding rule.
    /// The portRange field has the following limitations:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portRange")]
    #[builder(default)]
    pub port_range: Option<String>,
    /// The ports, portRange, and allPorts fields are mutually exclusive.
    /// Only packets addressed to ports in the specified range will be forwarded
    /// to the backends configured with this forwarding rule.
    /// The ports field has the following limitations:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ports: Option<Vec<String>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// this is used in psc consumer forwardingrule to make provider recreate the forwardingrule when the status is closed
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recreateClosedPsc")]
    #[builder(default)]
    pub recreate_closed_psc: Option<bool>,
    /// Service Directory resources to register this forwarding rule with.
    /// Currently, only supports a single Service Directory resource.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDirectoryRegistrations")]
    #[builder(default)]
    pub service_directory_registrations: Option<ForwardingRuleInitProviderServiceDirectoryRegistrations>,
    /// An optional prefix to the service name for this Forwarding Rule.
    /// If specified, will be the first label of the fully qualified service
    /// name.
    /// The label must be 1-63 characters long, and comply with RFC1035.
    /// Specifically, the label must be 1-63 characters long and match the
    /// regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first
    /// character must be a lowercase letter, and all following characters
    /// must be a dash, lowercase letter, or digit, except the last
    /// character, which cannot be a dash.
    /// This field is only used for INTERNAL load balancing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceLabel")]
    #[builder(default)]
    pub service_label: Option<String>,
    /// If not empty, this Forwarding Rule will only forward the traffic when the source IP address matches one of the IP addresses or CIDR ranges set here. Note that a Forwarding Rule can only have up to 64 source IP ranges, and this field can only be used with a regional Forwarding Rule whose scheme is EXTERNAL. Each sourceIpRange entry should be either an IP address (for example, 1.2.3.4) or a CIDR range (for example, 1.2.3.0/24).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceIpRanges")]
    #[builder(default)]
    pub source_ip_ranges: Option<Vec<String>>,
    /// This field identifies the subnetwork that the load balanced IP should
    /// belong to for this Forwarding Rule, used in internal load balancing and
    /// network load balancing with IPv6.
    /// If the network specified is in auto subnet mode, this field is optional.
    /// However, a subnetwork must be specified if the network is in custom subnet
    /// mode or when creating external forwarding rule with IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    #[builder(default)]
    pub subnetwork_ref: Option<ForwardingRuleInitProviderSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    #[builder(default)]
    pub subnetwork_selector: Option<ForwardingRuleInitProviderSubnetworkSelector>,
    /// is set to targetGrpcProxy and
    /// validateForProxyless is set to true, the
    /// IPAddress should be set to 0.0.0.0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub target: Option<String>,
    /// Reference to a RegionTargetHTTPProxy in compute to populate target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetRef")]
    #[builder(default)]
    pub target_ref: Option<ForwardingRuleInitProviderTargetRef>,
    /// Selector for a RegionTargetHTTPProxy in compute to populate target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSelector")]
    #[builder(default)]
    pub target_selector: Option<ForwardingRuleInitProviderTargetSelector>,
}

/// Reference to a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleInitProviderBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleInitProviderBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleInitProviderBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionBackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleInitProviderBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleInitProviderBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleInitProviderBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Address in compute to populate ipAddress.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderIpAddressRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleInitProviderIpAddressRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderIpAddressRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleInitProviderIpAddressRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleInitProviderIpAddressRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderIpAddressRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderIpAddressRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Address in compute to populate ipAddress.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderIpAddressSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleInitProviderIpAddressSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderIpAddressSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleInitProviderIpAddressSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleInitProviderIpAddressSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderIpAddressSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderIpAddressSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleInitProviderNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleInitProviderNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleInitProviderNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleInitProviderNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleInitProviderNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleInitProviderNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Service Directory resources to register this forwarding rule with.
/// Currently, only supports a single Service Directory resource.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderServiceDirectoryRegistrations {
    /// Service Directory namespace to register the forwarding rule under.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespace: Option<String>,
    /// Service Directory service to register the forwarding rule under.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleInitProviderSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleInitProviderSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleInitProviderSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleInitProviderSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleInitProviderSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleInitProviderSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a RegionTargetHTTPProxy in compute to populate target.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderTargetRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleInitProviderTargetRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderTargetRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleInitProviderTargetRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleInitProviderTargetRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderTargetRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderTargetRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionTargetHTTPProxy in compute to populate target.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderTargetSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleInitProviderTargetSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleInitProviderTargetSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleInitProviderTargetSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleInitProviderTargetSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderTargetSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleInitProviderTargetSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRuleProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRuleProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRuleProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRuleProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRulePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<ForwardingRulePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<ForwardingRulePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRulePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ForwardingRulePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRulePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ForwardingRulePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ForwardingRulePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRulePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ForwardingRulePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRulePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ForwardingRuleStatus defines the observed state of ForwardingRule.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<ForwardingRuleStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleStatusAtProvider {
    /// The ports, portRange, and allPorts fields are mutually exclusive.
    /// Only packets addressed to ports in the specified range will be forwarded
    /// to the backends configured with this forwarding rule.
    /// The allPorts field has the following limitations:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allPorts")]
    #[builder(default)]
    pub all_ports: Option<bool>,
    /// This field is used along with the backend_service field for
    /// internal load balancing or with the target field for internal
    /// TargetInstance.
    /// If the field is set to TRUE, clients can access ILB from all
    /// regions.
    /// Otherwise only allows access from clients in the same region as the
    /// internal load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowGlobalAccess")]
    #[builder(default)]
    pub allow_global_access: Option<bool>,
    /// This is used in PSC consumer ForwardingRule to control whether the PSC endpoint can be accessed from another region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPscGlobalAccess")]
    #[builder(default)]
    pub allow_psc_global_access: Option<bool>,
    /// Identifies the backend service to which the forwarding rule sends traffic.
    /// Required for Internal TCP/UDP Load Balancing and Network Load Balancing;
    /// must be omitted for all other load balancer types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// [Output Only] The URL for the corresponding base Forwarding Rule. By base Forwarding Rule, we mean the Forwarding Rule that has the same IP address, protocol, and port settings with the current Forwarding Rule, but without sourceIPRanges specified. Always empty if the current Forwarding Rule does not have sourceIPRanges specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseForwardingRule")]
    #[builder(default)]
    pub base_forwarding_rule: Option<String>,
    /// Creation timestamp in RFC3339 text format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationTimestamp")]
    #[builder(default)]
    pub creation_timestamp: Option<String>,
    /// An optional description of this resource. Provide this property when
    /// you create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveLabels")]
    #[builder(default)]
    pub effective_labels: Option<HashMap<String, String>>,
    /// The unique identifier number for the resource. This identifier is defined by the server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forwardingRuleId")]
    #[builder(default)]
    pub forwarding_rule_id: Option<f64>,
    /// an identifier for the resource with format projects/{{project}}/regions/{{region}}/forwardingRules/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// IP address for which this forwarding rule accepts traffic. When a client
    /// sends traffic to this IP address, the forwarding rule directs the traffic
    /// to the referenced target or backendService.
    /// While creating a forwarding rule, specifying an IPAddress is
    /// required under the following circumstances:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default)]
    pub ip_address: Option<String>,
    /// The IP protocol to which this rule applies.
    /// For protocol forwarding, valid
    /// options are TCP, UDP, ESP,
    /// AH, SCTP, ICMP and
    /// L3_DEFAULT.
    /// The valid IP protocols are different for different load balancing products
    /// as described in Load balancing
    /// features.
    /// A Forwarding Rule with protocol L3_DEFAULT can attach with target instance or
    /// backend service with UNSPECIFIED protocol.
    /// A forwarding rule with "L3_DEFAULT" IPProtocal cannot be attached to a backend service with TCP or UDP.
    /// Possible values are: TCP, UDP, ESP, AH, SCTP, ICMP, L3_DEFAULT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipProtocol")]
    #[builder(default)]
    pub ip_protocol: Option<String>,
    /// The IP address version that will be used by this forwarding rule.
    /// Valid options are IPV4 and IPV6.
    /// If not set, the IPv4 address will be used by default.
    /// Possible values are: IPV4, IPV6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipVersion")]
    #[builder(default)]
    pub ip_version: Option<String>,
    /// Indicates whether or not this load balancer can be used as a collector for
    /// packet mirroring. To prevent mirroring loops, instances behind this
    /// load balancer will not have their traffic mirrored even if a
    /// PacketMirroring rule applies to them.
    /// This can only be set to true for load balancers that have their
    /// loadBalancingScheme set to INTERNAL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isMirroringCollector")]
    #[builder(default)]
    pub is_mirroring_collector: Option<bool>,
    /// The fingerprint used for optimistic locking of this resource.  Used
    /// internally during updates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelFingerprint")]
    #[builder(default)]
    pub label_fingerprint: Option<String>,
    /// Labels to apply to this forwarding rule.  A list of key->value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Specifies the forwarding rule type.
    /// For more information about forwarding rules, refer to
    /// Forwarding rule concepts.
    /// Default value is EXTERNAL.
    /// Possible values are: EXTERNAL, EXTERNAL_MANAGED, INTERNAL, INTERNAL_MANAGED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingScheme")]
    #[builder(default)]
    pub load_balancing_scheme: Option<String>,
    /// This field is not used for external load balancing.
    /// For Internal TCP/UDP Load Balancing, this field identifies the network that
    /// the load balanced IP should belong to for this Forwarding Rule.
    /// If the subnetwork is specified, the network of the subnetwork will be used.
    /// If neither subnetwork nor this field is specified, the default network will
    /// be used.
    /// For Private Service Connect forwarding rules that forward traffic to Google
    /// APIs, a network must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// This signifies the networking tier used for configuring
    /// this load balancer and can only take the following values:
    /// PREMIUM, STANDARD.
    /// For regional ForwardingRule, the valid values are PREMIUM and
    /// STANDARD. For GlobalForwardingRule, the valid value is
    /// PREMIUM.
    /// If this field is not specified, it is assumed to be PREMIUM.
    /// If IPAddress is specified, this value must be equal to the
    /// networkTier of the Address.
    /// Possible values are: PREMIUM, STANDARD.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
    /// This is used in PSC consumer ForwardingRule to control whether it should try to auto-generate a DNS zone or not. Non-PSC forwarding rules do not use this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noAutomateDnsZone")]
    #[builder(default)]
    pub no_automate_dns_zone: Option<bool>,
    /// The ports, portRange, and allPorts fields are mutually exclusive.
    /// Only packets addressed to ports in the specified range will be forwarded
    /// to the backends configured with this forwarding rule.
    /// The portRange field has the following limitations:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portRange")]
    #[builder(default)]
    pub port_range: Option<String>,
    /// The ports, portRange, and allPorts fields are mutually exclusive.
    /// Only packets addressed to ports in the specified range will be forwarded
    /// to the backends configured with this forwarding rule.
    /// The ports field has the following limitations:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ports: Option<Vec<String>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The PSC connection id of the PSC Forwarding Rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pscConnectionId")]
    #[builder(default)]
    pub psc_connection_id: Option<String>,
    /// The PSC connection status of the PSC Forwarding Rule. Possible values: STATUS_UNSPECIFIED, PENDING, ACCEPTED, REJECTED, CLOSED
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pscConnectionStatus")]
    #[builder(default)]
    pub psc_connection_status: Option<String>,
    /// this is used in psc consumer forwardingrule to make provider recreate the forwardingrule when the status is closed
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recreateClosedPsc")]
    #[builder(default)]
    pub recreate_closed_psc: Option<bool>,
    /// A reference to the region where the regional forwarding rule resides.
    /// This field is not applicable to global forwarding rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    /// The URI of the created resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLink")]
    #[builder(default)]
    pub self_link: Option<String>,
    /// Service Directory resources to register this forwarding rule with.
    /// Currently, only supports a single Service Directory resource.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDirectoryRegistrations")]
    #[builder(default)]
    pub service_directory_registrations: Option<ForwardingRuleStatusAtProviderServiceDirectoryRegistrations>,
    /// An optional prefix to the service name for this Forwarding Rule.
    /// If specified, will be the first label of the fully qualified service
    /// name.
    /// The label must be 1-63 characters long, and comply with RFC1035.
    /// Specifically, the label must be 1-63 characters long and match the
    /// regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first
    /// character must be a lowercase letter, and all following characters
    /// must be a dash, lowercase letter, or digit, except the last
    /// character, which cannot be a dash.
    /// This field is only used for INTERNAL load balancing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceLabel")]
    #[builder(default)]
    pub service_label: Option<String>,
    /// The internal fully qualified service name for this Forwarding Rule.
    /// This field is only used for INTERNAL load balancing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    #[builder(default)]
    pub service_name: Option<String>,
    /// If not empty, this Forwarding Rule will only forward the traffic when the source IP address matches one of the IP addresses or CIDR ranges set here. Note that a Forwarding Rule can only have up to 64 source IP ranges, and this field can only be used with a regional Forwarding Rule whose scheme is EXTERNAL. Each sourceIpRange entry should be either an IP address (for example, 1.2.3.4) or a CIDR range (for example, 1.2.3.0/24).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceIpRanges")]
    #[builder(default)]
    pub source_ip_ranges: Option<Vec<String>>,
    /// This field identifies the subnetwork that the load balanced IP should
    /// belong to for this Forwarding Rule, used in internal load balancing and
    /// network load balancing with IPv6.
    /// If the network specified is in auto subnet mode, this field is optional.
    /// However, a subnetwork must be specified if the network is in custom subnet
    /// mode or when creating external forwarding rule with IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// is set to targetGrpcProxy and
    /// validateForProxyless is set to true, the
    /// IPAddress should be set to 0.0.0.0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub target: Option<String>,
    /// The combination of labels configured directly on the resource
    /// and default labels configured on the provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terraformLabels")]
    #[builder(default)]
    pub terraform_labels: Option<HashMap<String, String>>,
}

/// Service Directory resources to register this forwarding rule with.
/// Currently, only supports a single Service Directory resource.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ForwardingRuleStatusAtProviderServiceDirectoryRegistrations {
    /// Service Directory namespace to register the forwarding rule under.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespace: Option<String>,
    /// Service Directory service to register the forwarding rule under.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
}

