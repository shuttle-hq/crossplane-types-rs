// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// LBTargetGroupSpec defines the desired state of LBTargetGroup
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "elbv2.aws.upbound.io", version = "v1beta2", kind = "LBTargetGroup", plural = "lbtargetgroups")]
#[kube(status = "LBTargetGroupStatus")]
pub struct LBTargetGroupSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<LBTargetGroupDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: LBTargetGroupForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<LBTargetGroupInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<LBTargetGroupProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<LBTargetGroupPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<LBTargetGroupWriteConnectionSecretToRef>,
}

/// LBTargetGroupSpec defines the desired state of LBTargetGroup
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupForProvider {
    /// Whether to terminate connections at the end of the deregistration timeout on Network Load Balancers. See doc for more information. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionTermination")]
    #[builder(default)]
    pub connection_termination: Option<bool>,
    /// Amount time for Elastic Load Balancing to wait before changing the state of a deregistering target from draining to unused. The range is 0-3600 seconds. The default value is 300 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deregistrationDelay")]
    #[builder(default)]
    pub deregistration_delay: Option<String>,
    /// Health Check configuration block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    #[builder(default)]
    pub health_check: Option<LBTargetGroupForProviderHealthCheck>,
    /// The type of IP addresses used by the target group, only supported when target type is set to ip. Possible values are ipv4 or ipv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddressType")]
    #[builder(default)]
    pub ip_address_type: Option<String>,
    /// Whether the request and response headers exchanged between the load balancer and the Lambda function include arrays of values or strings. Only applies when target_type is lambda. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaMultiValueHeadersEnabled")]
    #[builder(default)]
    pub lambda_multi_value_headers_enabled: Option<bool>,
    /// Determines how the load balancer selects targets when routing requests. Only applicable for Application Load Balancer Target Groups. The value is round_robin, least_outstanding_requests, or weighted_random. The default is round_robin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingAlgorithmType")]
    #[builder(default)]
    pub load_balancing_algorithm_type: Option<String>,
    /// Determines whether to enable target anomaly mitigation.  Target anomaly mitigation is only supported by the weighted_random load balancing algorithm type.  See doc for more information.  The value is "on" or "off". The default is "off".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingAnomalyMitigation")]
    #[builder(default)]
    pub load_balancing_anomaly_mitigation: Option<String>,
    /// Indicates whether cross zone load balancing is enabled. The value is "true", "false" or "use_load_balancer_configuration". The default is "use_load_balancer_configuration".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingCrossZoneEnabled")]
    #[builder(default)]
    pub load_balancing_cross_zone_enabled: Option<String>,
    /// Name of the target group. This name must be unique per region per account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// (May be required, Forces new resource) Port on which targets receive traffic, unless overridden when registering a specific target. Required when target_type is instance, ip or alb. Does not apply when target_type is lambda.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
    /// Whether client IP preservation is enabled. See doc for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preserveClientIp")]
    #[builder(default)]
    pub preserve_client_ip: Option<String>,
    /// (May be required, Forces new resource) Protocol to use for routing traffic to the targets.
    /// Should be one of GENEVE, HTTP, HTTPS, TCP, TCP_UDP, TLS, or UDP.
    /// Required when target_type is instance, ip, or alb.
    /// Does not apply when target_type is lambda.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub protocol: Option<String>,
    /// Only applicable when protocol is HTTP or HTTPS. The protocol version. Specify GRPC to send requests to targets using gRPC. Specify HTTP2 to send requests to targets using HTTP/2. The default is HTTP1, which sends requests to targets using HTTP/1.1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protocolVersion")]
    #[builder(default)]
    pub protocol_version: Option<String>,
    /// Whether to enable support for proxy protocol v2 on Network Load Balancers. See doc for more information. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyProtocolV2")]
    #[builder(default)]
    pub proxy_protocol_v2: Option<bool>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Amount time for targets to warm up before the load balancer sends them a full share of requests. The range is 30-900 seconds or 0 to disable. The default value is 0 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "slowStart")]
    #[builder(default)]
    pub slow_start: Option<f64>,
    /// Stickiness configuration block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stickiness: Option<LBTargetGroupForProviderStickiness>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// Target failover block. Only applicable for Gateway Load Balancer target groups. See target_failover for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFailover")]
    #[builder(default)]
    pub target_failover: Option<Vec<LBTargetGroupForProviderTargetFailover>>,
    /// Target health requirements block. See target_group_health for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupHealth")]
    #[builder(default)]
    pub target_group_health: Option<LBTargetGroupForProviderTargetGroupHealth>,
    /// Target health state block. Only applicable for Network Load Balancer target groups when protocol is TCP or TLS. See target_health_state for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetHealthState")]
    #[builder(default)]
    pub target_health_state: Option<Vec<LBTargetGroupForProviderTargetHealthState>>,
    /// Type of target that you must specify when registering targets with this target group.
    /// See doc for supported values.
    /// The default is instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetType")]
    #[builder(default)]
    pub target_type: Option<String>,
    /// Identifier of the VPC in which to create the target group. Required when target_type is instance, ip or alb. Does not apply when target_type is lambda.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default)]
    pub vpc_id: Option<String>,
    /// Reference to a VPC in ec2 to populate vpcId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcIdRef")]
    #[builder(default)]
    pub vpc_id_ref: Option<LBTargetGroupForProviderVpcIdRef>,
    /// Selector for a VPC in ec2 to populate vpcId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcIdSelector")]
    #[builder(default)]
    pub vpc_id_selector: Option<LBTargetGroupForProviderVpcIdSelector>,
}

/// Health Check configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupForProviderHealthCheck {
    /// Whether health checks are enabled. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Number of consecutive health check successes required before considering a target healthy. The range is 2-10. Defaults to 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthyThreshold")]
    #[builder(default)]
    pub healthy_threshold: Option<f64>,
    /// Approximate amount of time, in seconds, between health checks of an individual target. The range is 5-300. For lambda target groups, it needs to be greater than the timeout of the underlying lambda. Defaults to 30.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub interval: Option<f64>,
    /// separated individual values (e.g., "200,202") or a range of values (e.g., "200-299").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub matcher: Option<String>,
    /// (May be required) Destination for the health check request. Required for HTTP/HTTPS ALB and HTTP NLB. Only applies to HTTP/HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// The port the load balancer uses when performing health checks on targets.
    /// Valid values are either traffic-port, to use the same port as the target group, or a valid port number between 1 and 65536.
    /// Default is traffic-port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<String>,
    /// Protocol the load balancer uses when performing health checks on targets.
    /// Must be one of TCP, HTTP, or HTTPS.
    /// The TCP protocol is not supported for health checks if the protocol of the target group is HTTP or HTTPS.
    /// Default is HTTP.
    /// Cannot be specified when the target_type is lambda.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub protocol: Option<String>,
    /// Amount of time, in seconds, during which no response from a target means a failed health check. The range is 2–120 seconds. For target groups with a protocol of HTTP, the default is 6 seconds. For target groups with a protocol of TCP, TLS or HTTPS, the default is 10 seconds. For target groups with a protocol of GENEVE, the default is 5 seconds. If the target type is lambda, the default is 30 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<f64>,
    /// Number of consecutive health check failures required before considering a target unhealthy. The range is 2-10. Defaults to 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyThreshold")]
    #[builder(default)]
    pub unhealthy_threshold: Option<f64>,
}

/// Stickiness configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupForProviderStickiness {
    /// Only used when the type is lb_cookie. The time period, in seconds, during which requests from a client should be routed to the same target. After this time period expires, the load balancer-generated cookie is considered stale. The range is 1 second to 1 week (604800 seconds). The default value is 1 day (86400 seconds).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cookieDuration")]
    #[builder(default)]
    pub cookie_duration: Option<f64>,
    /// Name of the application based cookie. AWSALB, AWSALBAPP, and AWSALBTG prefixes are reserved and cannot be used. Only needed when type is app_cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cookieName")]
    #[builder(default)]
    pub cookie_name: Option<String>,
    /// Whether health checks are enabled. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// The type of sticky sessions. The only current possible values are lb_cookie, app_cookie for ALBs, source_ip for NLBs, and source_ip_dest_ip, source_ip_dest_ip_proto for GWLBs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupForProviderTargetFailover {
    /// Indicates how the GWLB handles existing flows when a target is deregistered. Possible values are rebalance and no_rebalance. Must match the attribute value set for on_unhealthy. Default: no_rebalance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDeregistration")]
    #[builder(default)]
    pub on_deregistration: Option<String>,
    /// Indicates how the GWLB handles existing flows when a target is unhealthy. Possible values are rebalance and no_rebalance. Must match the attribute value set for on_deregistration. Default: no_rebalance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onUnhealthy")]
    #[builder(default)]
    pub on_unhealthy: Option<String>,
}

/// Target health requirements block. See target_group_health for more information.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupForProviderTargetGroupHealth {
    /// Block to configure DNS Failover requirements. See DNS Failover below for details on attributes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsFailover")]
    #[builder(default)]
    pub dns_failover: Option<LBTargetGroupForProviderTargetGroupHealthDnsFailover>,
    /// Block to configure Unhealthy State Routing requirements. See Unhealthy State Routing below for details on attributes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyStateRouting")]
    #[builder(default)]
    pub unhealthy_state_routing: Option<LBTargetGroupForProviderTargetGroupHealthUnhealthyStateRouting>,
}

/// Block to configure DNS Failover requirements. See DNS Failover below for details on attributes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupForProviderTargetGroupHealthDnsFailover {
    /// The minimum number of targets that must be healthy. If the number of healthy targets is below this value, mark the zone as unhealthy in DNS, so that traffic is routed only to healthy zones. The possible values are off or an integer from 1 to the maximum number of targets. The default is off.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHealthyTargetsCount")]
    #[builder(default)]
    pub minimum_healthy_targets_count: Option<String>,
    /// The minimum percentage of targets that must be healthy. If the percentage of healthy targets is below this value, mark the zone as unhealthy in DNS, so that traffic is routed only to healthy zones. The possible values are off or an integer from 1 to 100. The default is off.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHealthyTargetsPercentage")]
    #[builder(default)]
    pub minimum_healthy_targets_percentage: Option<String>,
}

/// Block to configure Unhealthy State Routing requirements. See Unhealthy State Routing below for details on attributes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupForProviderTargetGroupHealthUnhealthyStateRouting {
    /// The minimum number of targets that must be healthy. If the number of healthy targets is below this value, send traffic to all targets, including unhealthy targets. The possible values are 1 to the maximum number of targets. The default is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHealthyTargetsCount")]
    #[builder(default)]
    pub minimum_healthy_targets_count: Option<f64>,
    /// The minimum percentage of targets that must be healthy. If the percentage of healthy targets is below this value, send traffic to all targets, including unhealthy targets. The possible values are off or an integer from 1 to 100. The default is off.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHealthyTargetsPercentage")]
    #[builder(default)]
    pub minimum_healthy_targets_percentage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupForProviderTargetHealthState {
    /// Indicates whether the load balancer terminates connections to unhealthy targets. Possible values are true or false. Default: true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableUnhealthyConnectionTermination")]
    #[builder(default)]
    pub enable_unhealthy_connection_termination: Option<bool>,
    /// Indicates the time to wait for in-flight requests to complete when a target becomes unhealthy. The range is 0-360000. This value has to be set only if enable_unhealthy_connection_termination is set to false. Default: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyDrainingInterval")]
    #[builder(default)]
    pub unhealthy_draining_interval: Option<f64>,
}

/// Reference to a VPC in ec2 to populate vpcId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupForProviderVpcIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<LBTargetGroupForProviderVpcIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupForProviderVpcIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<LBTargetGroupForProviderVpcIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<LBTargetGroupForProviderVpcIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupForProviderVpcIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupForProviderVpcIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPC in ec2 to populate vpcId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupForProviderVpcIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<LBTargetGroupForProviderVpcIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupForProviderVpcIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<LBTargetGroupForProviderVpcIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<LBTargetGroupForProviderVpcIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupForProviderVpcIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupForProviderVpcIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupInitProvider {
    /// Whether to terminate connections at the end of the deregistration timeout on Network Load Balancers. See doc for more information. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionTermination")]
    #[builder(default)]
    pub connection_termination: Option<bool>,
    /// Amount time for Elastic Load Balancing to wait before changing the state of a deregistering target from draining to unused. The range is 0-3600 seconds. The default value is 300 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deregistrationDelay")]
    #[builder(default)]
    pub deregistration_delay: Option<String>,
    /// Health Check configuration block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    #[builder(default)]
    pub health_check: Option<LBTargetGroupInitProviderHealthCheck>,
    /// The type of IP addresses used by the target group, only supported when target type is set to ip. Possible values are ipv4 or ipv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddressType")]
    #[builder(default)]
    pub ip_address_type: Option<String>,
    /// Whether the request and response headers exchanged between the load balancer and the Lambda function include arrays of values or strings. Only applies when target_type is lambda. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaMultiValueHeadersEnabled")]
    #[builder(default)]
    pub lambda_multi_value_headers_enabled: Option<bool>,
    /// Determines how the load balancer selects targets when routing requests. Only applicable for Application Load Balancer Target Groups. The value is round_robin, least_outstanding_requests, or weighted_random. The default is round_robin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingAlgorithmType")]
    #[builder(default)]
    pub load_balancing_algorithm_type: Option<String>,
    /// Determines whether to enable target anomaly mitigation.  Target anomaly mitigation is only supported by the weighted_random load balancing algorithm type.  See doc for more information.  The value is "on" or "off". The default is "off".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingAnomalyMitigation")]
    #[builder(default)]
    pub load_balancing_anomaly_mitigation: Option<String>,
    /// Indicates whether cross zone load balancing is enabled. The value is "true", "false" or "use_load_balancer_configuration". The default is "use_load_balancer_configuration".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingCrossZoneEnabled")]
    #[builder(default)]
    pub load_balancing_cross_zone_enabled: Option<String>,
    /// Name of the target group. This name must be unique per region per account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// (May be required, Forces new resource) Port on which targets receive traffic, unless overridden when registering a specific target. Required when target_type is instance, ip or alb. Does not apply when target_type is lambda.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
    /// Whether client IP preservation is enabled. See doc for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preserveClientIp")]
    #[builder(default)]
    pub preserve_client_ip: Option<String>,
    /// (May be required, Forces new resource) Protocol to use for routing traffic to the targets.
    /// Should be one of GENEVE, HTTP, HTTPS, TCP, TCP_UDP, TLS, or UDP.
    /// Required when target_type is instance, ip, or alb.
    /// Does not apply when target_type is lambda.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub protocol: Option<String>,
    /// Only applicable when protocol is HTTP or HTTPS. The protocol version. Specify GRPC to send requests to targets using gRPC. Specify HTTP2 to send requests to targets using HTTP/2. The default is HTTP1, which sends requests to targets using HTTP/1.1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protocolVersion")]
    #[builder(default)]
    pub protocol_version: Option<String>,
    /// Whether to enable support for proxy protocol v2 on Network Load Balancers. See doc for more information. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyProtocolV2")]
    #[builder(default)]
    pub proxy_protocol_v2: Option<bool>,
    /// Amount time for targets to warm up before the load balancer sends them a full share of requests. The range is 30-900 seconds or 0 to disable. The default value is 0 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "slowStart")]
    #[builder(default)]
    pub slow_start: Option<f64>,
    /// Stickiness configuration block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stickiness: Option<LBTargetGroupInitProviderStickiness>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// Target failover block. Only applicable for Gateway Load Balancer target groups. See target_failover for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFailover")]
    #[builder(default)]
    pub target_failover: Option<Vec<LBTargetGroupInitProviderTargetFailover>>,
    /// Target health requirements block. See target_group_health for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupHealth")]
    #[builder(default)]
    pub target_group_health: Option<LBTargetGroupInitProviderTargetGroupHealth>,
    /// Target health state block. Only applicable for Network Load Balancer target groups when protocol is TCP or TLS. See target_health_state for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetHealthState")]
    #[builder(default)]
    pub target_health_state: Option<Vec<LBTargetGroupInitProviderTargetHealthState>>,
    /// Type of target that you must specify when registering targets with this target group.
    /// See doc for supported values.
    /// The default is instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetType")]
    #[builder(default)]
    pub target_type: Option<String>,
    /// Identifier of the VPC in which to create the target group. Required when target_type is instance, ip or alb. Does not apply when target_type is lambda.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default)]
    pub vpc_id: Option<String>,
    /// Reference to a VPC in ec2 to populate vpcId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcIdRef")]
    #[builder(default)]
    pub vpc_id_ref: Option<LBTargetGroupInitProviderVpcIdRef>,
    /// Selector for a VPC in ec2 to populate vpcId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcIdSelector")]
    #[builder(default)]
    pub vpc_id_selector: Option<LBTargetGroupInitProviderVpcIdSelector>,
}

/// Health Check configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupInitProviderHealthCheck {
    /// Whether health checks are enabled. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Number of consecutive health check successes required before considering a target healthy. The range is 2-10. Defaults to 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthyThreshold")]
    #[builder(default)]
    pub healthy_threshold: Option<f64>,
    /// Approximate amount of time, in seconds, between health checks of an individual target. The range is 5-300. For lambda target groups, it needs to be greater than the timeout of the underlying lambda. Defaults to 30.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub interval: Option<f64>,
    /// separated individual values (e.g., "200,202") or a range of values (e.g., "200-299").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub matcher: Option<String>,
    /// (May be required) Destination for the health check request. Required for HTTP/HTTPS ALB and HTTP NLB. Only applies to HTTP/HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// The port the load balancer uses when performing health checks on targets.
    /// Valid values are either traffic-port, to use the same port as the target group, or a valid port number between 1 and 65536.
    /// Default is traffic-port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<String>,
    /// Protocol the load balancer uses when performing health checks on targets.
    /// Must be one of TCP, HTTP, or HTTPS.
    /// The TCP protocol is not supported for health checks if the protocol of the target group is HTTP or HTTPS.
    /// Default is HTTP.
    /// Cannot be specified when the target_type is lambda.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub protocol: Option<String>,
    /// Amount of time, in seconds, during which no response from a target means a failed health check. The range is 2–120 seconds. For target groups with a protocol of HTTP, the default is 6 seconds. For target groups with a protocol of TCP, TLS or HTTPS, the default is 10 seconds. For target groups with a protocol of GENEVE, the default is 5 seconds. If the target type is lambda, the default is 30 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<f64>,
    /// Number of consecutive health check failures required before considering a target unhealthy. The range is 2-10. Defaults to 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyThreshold")]
    #[builder(default)]
    pub unhealthy_threshold: Option<f64>,
}

/// Stickiness configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupInitProviderStickiness {
    /// Only used when the type is lb_cookie. The time period, in seconds, during which requests from a client should be routed to the same target. After this time period expires, the load balancer-generated cookie is considered stale. The range is 1 second to 1 week (604800 seconds). The default value is 1 day (86400 seconds).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cookieDuration")]
    #[builder(default)]
    pub cookie_duration: Option<f64>,
    /// Name of the application based cookie. AWSALB, AWSALBAPP, and AWSALBTG prefixes are reserved and cannot be used. Only needed when type is app_cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cookieName")]
    #[builder(default)]
    pub cookie_name: Option<String>,
    /// Whether health checks are enabled. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// The type of sticky sessions. The only current possible values are lb_cookie, app_cookie for ALBs, source_ip for NLBs, and source_ip_dest_ip, source_ip_dest_ip_proto for GWLBs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupInitProviderTargetFailover {
    /// Indicates how the GWLB handles existing flows when a target is deregistered. Possible values are rebalance and no_rebalance. Must match the attribute value set for on_unhealthy. Default: no_rebalance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDeregistration")]
    #[builder(default)]
    pub on_deregistration: Option<String>,
    /// Indicates how the GWLB handles existing flows when a target is unhealthy. Possible values are rebalance and no_rebalance. Must match the attribute value set for on_deregistration. Default: no_rebalance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onUnhealthy")]
    #[builder(default)]
    pub on_unhealthy: Option<String>,
}

/// Target health requirements block. See target_group_health for more information.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupInitProviderTargetGroupHealth {
    /// Block to configure DNS Failover requirements. See DNS Failover below for details on attributes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsFailover")]
    #[builder(default)]
    pub dns_failover: Option<LBTargetGroupInitProviderTargetGroupHealthDnsFailover>,
    /// Block to configure Unhealthy State Routing requirements. See Unhealthy State Routing below for details on attributes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyStateRouting")]
    #[builder(default)]
    pub unhealthy_state_routing: Option<LBTargetGroupInitProviderTargetGroupHealthUnhealthyStateRouting>,
}

/// Block to configure DNS Failover requirements. See DNS Failover below for details on attributes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupInitProviderTargetGroupHealthDnsFailover {
    /// The minimum number of targets that must be healthy. If the number of healthy targets is below this value, mark the zone as unhealthy in DNS, so that traffic is routed only to healthy zones. The possible values are off or an integer from 1 to the maximum number of targets. The default is off.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHealthyTargetsCount")]
    #[builder(default)]
    pub minimum_healthy_targets_count: Option<String>,
    /// The minimum percentage of targets that must be healthy. If the percentage of healthy targets is below this value, mark the zone as unhealthy in DNS, so that traffic is routed only to healthy zones. The possible values are off or an integer from 1 to 100. The default is off.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHealthyTargetsPercentage")]
    #[builder(default)]
    pub minimum_healthy_targets_percentage: Option<String>,
}

/// Block to configure Unhealthy State Routing requirements. See Unhealthy State Routing below for details on attributes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupInitProviderTargetGroupHealthUnhealthyStateRouting {
    /// The minimum number of targets that must be healthy. If the number of healthy targets is below this value, send traffic to all targets, including unhealthy targets. The possible values are 1 to the maximum number of targets. The default is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHealthyTargetsCount")]
    #[builder(default)]
    pub minimum_healthy_targets_count: Option<f64>,
    /// The minimum percentage of targets that must be healthy. If the percentage of healthy targets is below this value, send traffic to all targets, including unhealthy targets. The possible values are off or an integer from 1 to 100. The default is off.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHealthyTargetsPercentage")]
    #[builder(default)]
    pub minimum_healthy_targets_percentage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupInitProviderTargetHealthState {
    /// Indicates whether the load balancer terminates connections to unhealthy targets. Possible values are true or false. Default: true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableUnhealthyConnectionTermination")]
    #[builder(default)]
    pub enable_unhealthy_connection_termination: Option<bool>,
    /// Indicates the time to wait for in-flight requests to complete when a target becomes unhealthy. The range is 0-360000. This value has to be set only if enable_unhealthy_connection_termination is set to false. Default: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyDrainingInterval")]
    #[builder(default)]
    pub unhealthy_draining_interval: Option<f64>,
}

/// Reference to a VPC in ec2 to populate vpcId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupInitProviderVpcIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<LBTargetGroupInitProviderVpcIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupInitProviderVpcIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<LBTargetGroupInitProviderVpcIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<LBTargetGroupInitProviderVpcIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupInitProviderVpcIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupInitProviderVpcIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPC in ec2 to populate vpcId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupInitProviderVpcIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<LBTargetGroupInitProviderVpcIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupInitProviderVpcIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<LBTargetGroupInitProviderVpcIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<LBTargetGroupInitProviderVpcIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupInitProviderVpcIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupInitProviderVpcIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<LBTargetGroupProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<LBTargetGroupProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<LBTargetGroupProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<LBTargetGroupPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<LBTargetGroupPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<LBTargetGroupPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<LBTargetGroupPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<LBTargetGroupPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBTargetGroupPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// LBTargetGroupStatus defines the observed state of LBTargetGroup.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<LBTargetGroupStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupStatusAtProvider {
    /// ARN of the Target Group (matches id).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub arn: Option<String>,
    /// ARN suffix for use with CloudWatch Metrics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnSuffix")]
    #[builder(default)]
    pub arn_suffix: Option<String>,
    /// Whether to terminate connections at the end of the deregistration timeout on Network Load Balancers. See doc for more information. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionTermination")]
    #[builder(default)]
    pub connection_termination: Option<bool>,
    /// Amount time for Elastic Load Balancing to wait before changing the state of a deregistering target from draining to unused. The range is 0-3600 seconds. The default value is 300 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deregistrationDelay")]
    #[builder(default)]
    pub deregistration_delay: Option<String>,
    /// Health Check configuration block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    #[builder(default)]
    pub health_check: Option<LBTargetGroupStatusAtProviderHealthCheck>,
    /// ARN of the Target Group (matches arn).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The type of IP addresses used by the target group, only supported when target type is set to ip. Possible values are ipv4 or ipv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddressType")]
    #[builder(default)]
    pub ip_address_type: Option<String>,
    /// Whether the request and response headers exchanged between the load balancer and the Lambda function include arrays of values or strings. Only applies when target_type is lambda. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaMultiValueHeadersEnabled")]
    #[builder(default)]
    pub lambda_multi_value_headers_enabled: Option<bool>,
    /// ARNs of the Load Balancers associated with the Target Group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerArns")]
    #[builder(default)]
    pub load_balancer_arns: Option<Vec<String>>,
    /// Determines how the load balancer selects targets when routing requests. Only applicable for Application Load Balancer Target Groups. The value is round_robin, least_outstanding_requests, or weighted_random. The default is round_robin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingAlgorithmType")]
    #[builder(default)]
    pub load_balancing_algorithm_type: Option<String>,
    /// Determines whether to enable target anomaly mitigation.  Target anomaly mitigation is only supported by the weighted_random load balancing algorithm type.  See doc for more information.  The value is "on" or "off". The default is "off".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingAnomalyMitigation")]
    #[builder(default)]
    pub load_balancing_anomaly_mitigation: Option<String>,
    /// Indicates whether cross zone load balancing is enabled. The value is "true", "false" or "use_load_balancer_configuration". The default is "use_load_balancer_configuration".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancingCrossZoneEnabled")]
    #[builder(default)]
    pub load_balancing_cross_zone_enabled: Option<String>,
    /// Name of the target group. This name must be unique per region per account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// (May be required, Forces new resource) Port on which targets receive traffic, unless overridden when registering a specific target. Required when target_type is instance, ip or alb. Does not apply when target_type is lambda.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
    /// Whether client IP preservation is enabled. See doc for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preserveClientIp")]
    #[builder(default)]
    pub preserve_client_ip: Option<String>,
    /// (May be required, Forces new resource) Protocol to use for routing traffic to the targets.
    /// Should be one of GENEVE, HTTP, HTTPS, TCP, TCP_UDP, TLS, or UDP.
    /// Required when target_type is instance, ip, or alb.
    /// Does not apply when target_type is lambda.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub protocol: Option<String>,
    /// Only applicable when protocol is HTTP or HTTPS. The protocol version. Specify GRPC to send requests to targets using gRPC. Specify HTTP2 to send requests to targets using HTTP/2. The default is HTTP1, which sends requests to targets using HTTP/1.1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protocolVersion")]
    #[builder(default)]
    pub protocol_version: Option<String>,
    /// Whether to enable support for proxy protocol v2 on Network Load Balancers. See doc for more information. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyProtocolV2")]
    #[builder(default)]
    pub proxy_protocol_v2: Option<bool>,
    /// Amount time for targets to warm up before the load balancer sends them a full share of requests. The range is 30-900 seconds or 0 to disable. The default value is 0 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "slowStart")]
    #[builder(default)]
    pub slow_start: Option<f64>,
    /// Stickiness configuration block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stickiness: Option<LBTargetGroupStatusAtProviderStickiness>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default)]
    pub tags_all: Option<HashMap<String, String>>,
    /// Target failover block. Only applicable for Gateway Load Balancer target groups. See target_failover for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFailover")]
    #[builder(default)]
    pub target_failover: Option<Vec<LBTargetGroupStatusAtProviderTargetFailover>>,
    /// Target health requirements block. See target_group_health for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupHealth")]
    #[builder(default)]
    pub target_group_health: Option<LBTargetGroupStatusAtProviderTargetGroupHealth>,
    /// Target health state block. Only applicable for Network Load Balancer target groups when protocol is TCP or TLS. See target_health_state for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetHealthState")]
    #[builder(default)]
    pub target_health_state: Option<Vec<LBTargetGroupStatusAtProviderTargetHealthState>>,
    /// Type of target that you must specify when registering targets with this target group.
    /// See doc for supported values.
    /// The default is instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetType")]
    #[builder(default)]
    pub target_type: Option<String>,
    /// Identifier of the VPC in which to create the target group. Required when target_type is instance, ip or alb. Does not apply when target_type is lambda.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default)]
    pub vpc_id: Option<String>,
}

/// Health Check configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupStatusAtProviderHealthCheck {
    /// Whether health checks are enabled. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Number of consecutive health check successes required before considering a target healthy. The range is 2-10. Defaults to 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthyThreshold")]
    #[builder(default)]
    pub healthy_threshold: Option<f64>,
    /// Approximate amount of time, in seconds, between health checks of an individual target. The range is 5-300. For lambda target groups, it needs to be greater than the timeout of the underlying lambda. Defaults to 30.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub interval: Option<f64>,
    /// separated individual values (e.g., "200,202") or a range of values (e.g., "200-299").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub matcher: Option<String>,
    /// (May be required) Destination for the health check request. Required for HTTP/HTTPS ALB and HTTP NLB. Only applies to HTTP/HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// The port the load balancer uses when performing health checks on targets.
    /// Valid values are either traffic-port, to use the same port as the target group, or a valid port number between 1 and 65536.
    /// Default is traffic-port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<String>,
    /// Protocol the load balancer uses when performing health checks on targets.
    /// Must be one of TCP, HTTP, or HTTPS.
    /// The TCP protocol is not supported for health checks if the protocol of the target group is HTTP or HTTPS.
    /// Default is HTTP.
    /// Cannot be specified when the target_type is lambda.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub protocol: Option<String>,
    /// Amount of time, in seconds, during which no response from a target means a failed health check. The range is 2–120 seconds. For target groups with a protocol of HTTP, the default is 6 seconds. For target groups with a protocol of TCP, TLS or HTTPS, the default is 10 seconds. For target groups with a protocol of GENEVE, the default is 5 seconds. If the target type is lambda, the default is 30 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<f64>,
    /// Number of consecutive health check failures required before considering a target unhealthy. The range is 2-10. Defaults to 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyThreshold")]
    #[builder(default)]
    pub unhealthy_threshold: Option<f64>,
}

/// Stickiness configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupStatusAtProviderStickiness {
    /// Only used when the type is lb_cookie. The time period, in seconds, during which requests from a client should be routed to the same target. After this time period expires, the load balancer-generated cookie is considered stale. The range is 1 second to 1 week (604800 seconds). The default value is 1 day (86400 seconds).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cookieDuration")]
    #[builder(default)]
    pub cookie_duration: Option<f64>,
    /// Name of the application based cookie. AWSALB, AWSALBAPP, and AWSALBTG prefixes are reserved and cannot be used. Only needed when type is app_cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cookieName")]
    #[builder(default)]
    pub cookie_name: Option<String>,
    /// Whether health checks are enabled. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// The type of sticky sessions. The only current possible values are lb_cookie, app_cookie for ALBs, source_ip for NLBs, and source_ip_dest_ip, source_ip_dest_ip_proto for GWLBs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupStatusAtProviderTargetFailover {
    /// Indicates how the GWLB handles existing flows when a target is deregistered. Possible values are rebalance and no_rebalance. Must match the attribute value set for on_unhealthy. Default: no_rebalance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDeregistration")]
    #[builder(default)]
    pub on_deregistration: Option<String>,
    /// Indicates how the GWLB handles existing flows when a target is unhealthy. Possible values are rebalance and no_rebalance. Must match the attribute value set for on_deregistration. Default: no_rebalance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onUnhealthy")]
    #[builder(default)]
    pub on_unhealthy: Option<String>,
}

/// Target health requirements block. See target_group_health for more information.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupStatusAtProviderTargetGroupHealth {
    /// Block to configure DNS Failover requirements. See DNS Failover below for details on attributes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsFailover")]
    #[builder(default)]
    pub dns_failover: Option<LBTargetGroupStatusAtProviderTargetGroupHealthDnsFailover>,
    /// Block to configure Unhealthy State Routing requirements. See Unhealthy State Routing below for details on attributes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyStateRouting")]
    #[builder(default)]
    pub unhealthy_state_routing: Option<LBTargetGroupStatusAtProviderTargetGroupHealthUnhealthyStateRouting>,
}

/// Block to configure DNS Failover requirements. See DNS Failover below for details on attributes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupStatusAtProviderTargetGroupHealthDnsFailover {
    /// The minimum number of targets that must be healthy. If the number of healthy targets is below this value, mark the zone as unhealthy in DNS, so that traffic is routed only to healthy zones. The possible values are off or an integer from 1 to the maximum number of targets. The default is off.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHealthyTargetsCount")]
    #[builder(default)]
    pub minimum_healthy_targets_count: Option<String>,
    /// The minimum percentage of targets that must be healthy. If the percentage of healthy targets is below this value, mark the zone as unhealthy in DNS, so that traffic is routed only to healthy zones. The possible values are off or an integer from 1 to 100. The default is off.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHealthyTargetsPercentage")]
    #[builder(default)]
    pub minimum_healthy_targets_percentage: Option<String>,
}

/// Block to configure Unhealthy State Routing requirements. See Unhealthy State Routing below for details on attributes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupStatusAtProviderTargetGroupHealthUnhealthyStateRouting {
    /// The minimum number of targets that must be healthy. If the number of healthy targets is below this value, send traffic to all targets, including unhealthy targets. The possible values are 1 to the maximum number of targets. The default is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHealthyTargetsCount")]
    #[builder(default)]
    pub minimum_healthy_targets_count: Option<f64>,
    /// The minimum percentage of targets that must be healthy. If the percentage of healthy targets is below this value, send traffic to all targets, including unhealthy targets. The possible values are off or an integer from 1 to 100. The default is off.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHealthyTargetsPercentage")]
    #[builder(default)]
    pub minimum_healthy_targets_percentage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct LBTargetGroupStatusAtProviderTargetHealthState {
    /// Indicates whether the load balancer terminates connections to unhealthy targets. Possible values are true or false. Default: true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableUnhealthyConnectionTermination")]
    #[builder(default)]
    pub enable_unhealthy_connection_termination: Option<bool>,
    /// Indicates the time to wait for in-flight requests to complete when a target becomes unhealthy. The range is 0-360000. This value has to be set only if enable_unhealthy_connection_termination is set to false. Default: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyDrainingInterval")]
    #[builder(default)]
    pub unhealthy_draining_interval: Option<f64>,
}

